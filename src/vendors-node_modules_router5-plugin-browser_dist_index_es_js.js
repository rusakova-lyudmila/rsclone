(self["webpackChunkrsclone"] = self["webpackChunkrsclone"] || []).push([["vendors-node_modules_router5-plugin-browser_dist_index_es_js"],{

/***/ "./node_modules/path-parser/dist/path-parser.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/path-parser/dist/path-parser.esm.js ***!
  \**********************************************************/
/*! namespace exports */
/*! export Path [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Path": () => /* binding */ Path
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var search_params__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! search-params */ "./node_modules/search-params/dist/search-params.esm.js");
;


/**
 * We encode using encodeURIComponent but we want to
 * preserver certain characters which are commonly used
 * (sub delimiters and ':')
 *
 * https://www.ietf.org/rfc/rfc3986.txt
 *
 * reserved    = gen-delims / sub-delims
 *
 * gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
 *
 * sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="
 */
var excludeSubDelimiters = /[^!$'()*+,;|:]/g;
var encodeURIComponentExcludingSubDelims = function encodeURIComponentExcludingSubDelims(segment) {
  return segment.replace(excludeSubDelimiters, function (match) {
    return encodeURIComponent(match);
  });
};
var encodingMethods = {
  "default": encodeURIComponentExcludingSubDelims,
  uri: encodeURI,
  uriComponent: encodeURIComponent,
  none: function none(val) {
    return val;
  },
  legacy: encodeURI
};
var decodingMethods = {
  "default": decodeURIComponent,
  uri: decodeURI,
  uriComponent: decodeURIComponent,
  none: function none(val) {
    return val;
  },
  legacy: decodeURIComponent
};
var encodeParam = function encodeParam(param, encoding, isSpatParam) {
  var encoder = encodingMethods[encoding] || encodeURIComponentExcludingSubDelims;

  if (isSpatParam) {
    return String(param).split('/').map(encoder).join('/');
  }

  return encoder(String(param));
};
var decodeParam = function decodeParam(param, encoding) {
  return (decodingMethods[encoding] || decodeURIComponent)(param);
};

var defaultOrConstrained = function defaultOrConstrained(match) {
  return '(' + (match ? match.replace(/(^<|>$)/g, '') : "[a-zA-Z0-9-_.~%':|=+\\*@$]+") + ')';
};
var rules = [{
  name: 'url-parameter',
  pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
  regex: function regex(match) {
    return new RegExp(defaultOrConstrained(match[2]));
  }
}, {
  name: 'url-parameter-splat',
  pattern: /^\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,
  regex: /([^?]*)/
}, {
  name: 'url-parameter-matrix',
  pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
  regex: function regex(match) {
    return new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]));
  }
}, {
  name: 'query-parameter',
  pattern: /^(?:\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/
}, {
  name: 'delimiter',
  pattern: /^(\/|\?)/,
  regex: function regex(match) {
    return new RegExp('\\' + match[0]);
  }
}, {
  name: 'sub-delimiter',
  pattern: /^(!|&|-|_|\.|;)/,
  regex: function regex(match) {
    return new RegExp(match[0]);
  }
}, {
  name: 'fragment',
  pattern: /^([0-9a-zA-Z]+)/,
  regex: function regex(match) {
    return new RegExp(match[0]);
  }
}];

var tokenise = function tokenise(str, tokens) {
  if (tokens === void 0) {
    tokens = [];
  } // Look for a matching rule


  var matched = rules.some(function (rule) {
    var match = str.match(rule.pattern);

    if (!match) {
      return false;
    }

    tokens.push({
      type: rule.name,
      match: match[0],
      val: match.slice(1, 2),
      otherVal: match.slice(2),
      regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex
    });

    if (match[0].length < str.length) {
      tokens = tokenise(str.substr(match[0].length), tokens);
    }

    return true;
  }); // If no rules matched, throw an error (possible malformed path)

  if (!matched) {
    throw new Error("Could not parse path '" + str + "'");
  }

  return tokens;
};

var exists = function exists(val) {
  return val !== undefined && val !== null;
};

var optTrailingSlash = function optTrailingSlash(source, strictTrailingSlash) {
  if (strictTrailingSlash) {
    return source;
  }

  if (source === '\\/') {
    return source;
  }

  return source.replace(/\\\/$/, '') + '(?:\\/)?';
};

var upToDelimiter = function upToDelimiter(source, delimiter) {
  if (!delimiter) {
    return source;
  }

  return /(\/)$/.test(source) ? source : source + '(\\/|\\?|\\.|;|$)';
};

var appendQueryParam = function appendQueryParam(params, param, val) {
  if (val === void 0) {
    val = '';
  }

  var existingVal = params[param];

  if (existingVal === undefined) {
    params[param] = val;
  } else {
    params[param] = Array.isArray(existingVal) ? existingVal.concat(val) : [existingVal, val];
  }

  return params;
};

var defaultOptions = {
  urlParamsEncoding: 'default'
};

var Path =
/*#__PURE__*/

/** @class */
function () {
  function Path(path, options) {
    if (!path) {
      throw new Error('Missing path in Path constructor');
    }

    this.path = path;
    this.options = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, defaultOptions), options);
    this.tokens = tokenise(path);
    this.hasUrlParams = this.tokens.filter(function (t) {
      return /^url-parameter/.test(t.type);
    }).length > 0;
    this.hasSpatParam = this.tokens.filter(function (t) {
      return /splat$/.test(t.type);
    }).length > 0;
    this.hasMatrixParams = this.tokens.filter(function (t) {
      return /matrix$/.test(t.type);
    }).length > 0;
    this.hasQueryParams = this.tokens.filter(function (t) {
      return /^query-parameter/.test(t.type);
    }).length > 0; // Extract named parameters from tokens

    this.spatParams = this.getParams('url-parameter-splat');
    this.urlParams = this.getParams(/^url-parameter/); // Query params

    this.queryParams = this.getParams('query-parameter'); // All params

    this.params = this.urlParams.concat(this.queryParams); // Check if hasQueryParams
    // Regular expressions for url part only (full and partial match)

    this.source = this.tokens.filter(function (t) {
      return t.regex !== undefined;
    }).map(function (t) {
      return t.regex.source;
    }).join('');
  }

  Path.createPath = function (path, options) {
    return new Path(path, options);
  };

  Path.prototype.isQueryParam = function (name) {
    return this.queryParams.indexOf(name) !== -1;
  };

  Path.prototype.isSpatParam = function (name) {
    return this.spatParams.indexOf(name) !== -1;
  };

  Path.prototype.test = function (path, opts) {
    var _this = this;

    var options = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
      caseSensitive: false,
      strictTrailingSlash: false
    }, this.options), opts); // trailingSlash: falsy => non optional, truthy => optional


    var source = optTrailingSlash(this.source, options.strictTrailingSlash); // Check if exact match

    var match = this.urlTest(path, source + (this.hasQueryParams ? '(\\?.*$|$)' : '$'), options.caseSensitive, options.urlParamsEncoding); // If no match, or no query params, no need to go further

    if (!match || !this.hasQueryParams) {
      return match;
    } // Extract query params


    var queryParams = (0,search_params__WEBPACK_IMPORTED_MODULE_1__.parse)(path, options.queryParams);
    var unexpectedQueryParams = Object.keys(queryParams).filter(function (p) {
      return !_this.isQueryParam(p);
    });

    if (unexpectedQueryParams.length === 0) {
      // Extend url match
      Object.keys(queryParams).forEach( // @ts-ignore
      function (p) {
        return match[p] = queryParams[p];
      });
      return match;
    }

    return null;
  };

  Path.prototype.partialTest = function (path, opts) {
    var _this = this;

    var options = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
      caseSensitive: false,
      delimited: true
    }, this.options), opts); // Check if partial match (start of given path matches regex)
    // trailingSlash: falsy => non optional, truthy => optional


    var source = upToDelimiter(this.source, options.delimited);
    var match = this.urlTest(path, source, options.caseSensitive, options.urlParamsEncoding);

    if (!match) {
      return match;
    }

    if (!this.hasQueryParams) {
      return match;
    }

    var queryParams = (0,search_params__WEBPACK_IMPORTED_MODULE_1__.parse)(path, options.queryParams);
    Object.keys(queryParams).filter(function (p) {
      return _this.isQueryParam(p);
    }).forEach(function (p) {
      return appendQueryParam(match, p, queryParams[p]);
    });
    return match;
  };

  Path.prototype.build = function (params, opts) {
    var _this = this;

    if (params === void 0) {
      params = {};
    }

    var options = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
      ignoreConstraints: false,
      ignoreSearch: false,
      queryParams: {}
    }, this.options), opts);

    var encodedUrlParams = Object.keys(params).filter(function (p) {
      return !_this.isQueryParam(p);
    }).reduce(function (acc, key) {
      if (!exists(params[key])) {
        return acc;
      }

      var val = params[key];

      var isSpatParam = _this.isSpatParam(key);

      if (typeof val === 'boolean') {
        acc[key] = val;
      } else if (Array.isArray(val)) {
        acc[key] = val.map(function (v) {
          return encodeParam(v, options.urlParamsEncoding, isSpatParam);
        });
      } else {
        acc[key] = encodeParam(val, options.urlParamsEncoding, isSpatParam);
      }

      return acc;
    }, {}); // Check all params are provided (not search parameters which are optional)

    if (this.urlParams.some(function (p) {
      return !exists(params[p]);
    })) {
      var missingParameters = this.urlParams.filter(function (p) {
        return !exists(params[p]);
      });
      throw new Error("Cannot build path: '" + this.path + "' requires missing parameters { " + missingParameters.join(', ') + ' }');
    } // Check constraints


    if (!options.ignoreConstraints) {
      var constraintsPassed = this.tokens.filter(function (t) {
        return /^url-parameter/.test(t.type) && !/-splat$/.test(t.type);
      }).every(function (t) {
        return new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(encodedUrlParams[t.val]);
      });

      if (!constraintsPassed) {
        throw new Error("Some parameters of '" + this.path + "' are of invalid format");
      }
    }

    var base = this.tokens.filter(function (t) {
      return /^query-parameter/.test(t.type) === false;
    }).map(function (t) {
      if (t.type === 'url-parameter-matrix') {
        return ";" + t.val + "=" + encodedUrlParams[t.val[0]];
      }

      return /^url-parameter/.test(t.type) ? encodedUrlParams[t.val[0]] : t.match;
    }).join('');

    if (options.ignoreSearch) {
      return base;
    }

    var searchParams = this.queryParams.filter(function (p) {
      return Object.keys(params).indexOf(p) !== -1;
    }).reduce(function (sparams, paramName) {
      sparams[paramName] = params[paramName];
      return sparams;
    }, {});
    var searchPart = (0,search_params__WEBPACK_IMPORTED_MODULE_1__.build)(searchParams, options.queryParams);
    return searchPart ? base + '?' + searchPart : base;
  };

  Path.prototype.getParams = function (type) {
    var predicate = type instanceof RegExp ? function (t) {
      return type.test(t.type);
    } : function (t) {
      return t.type === type;
    };
    return this.tokens.filter(predicate).map(function (t) {
      return t.val[0];
    });
  };

  Path.prototype.urlTest = function (path, source, caseSensitive, urlParamsEncoding) {
    var _this = this;

    var regex = new RegExp('^' + source, caseSensitive ? '' : 'i');
    var match = path.match(regex);

    if (!match) {
      return null;
    } else if (!this.urlParams.length) {
      return {};
    } // Reduce named params to key-value pairs


    return match.slice(1, this.urlParams.length + 1).reduce(function (params, m, i) {
      params[_this.urlParams[i]] = decodeParam(m, urlParamsEncoding);
      return params;
    }, {});
  };

  return Path;
}();


//# sourceMappingURL=path-parser.esm.js.map


/***/ }),

/***/ "./node_modules/route-node/dist/route-node.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/route-node/dist/route-node.esm.js ***!
  \********************************************************/
/*! namespace exports */
/*! export RouteNode [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouteNode": () => /* binding */ RouteNode
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var path_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path-parser */ "./node_modules/path-parser/dist/path-parser.esm.js");
/* harmony import */ var search_params__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! search-params */ "./node_modules/search-params/dist/search-params.esm.js");
;



var getMetaFromSegments = function getMetaFromSegments(segments) {
  var accName = '';
  return segments.reduce(function (meta, segment) {
    var _a, _b, _c, _d;

    var urlParams = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.urlParams.reduce(function (params, p) {
      params[p] = 'url';
      return params;
    }, {}), _b !== null && _b !== void 0 ? _b : {});
    var allParams = (_d = (_c = segment.parser) === null || _c === void 0 ? void 0 : _c.queryParams.reduce(function (params, p) {
      params[p] = 'query';
      return params;
    }, urlParams), _d !== null && _d !== void 0 ? _d : {});

    if (segment.name !== undefined) {
      accName = accName ? accName + '.' + segment.name : segment.name;
      meta[accName] = allParams;
    }

    return meta;
  }, {});
};
var buildStateFromMatch = function buildStateFromMatch(match) {
  if (!match || !match.segments || !match.segments.length) {
    return null;
  }

  var name = match.segments.map(function (segment) {
    return segment.name;
  }).filter(function (name) {
    return name;
  }).join('.');
  var params = match.params;
  return {
    name: name,
    params: params,
    meta: getMetaFromSegments(match.segments)
  };
};
var buildPathFromSegments = function buildPathFromSegments(segments, params, options) {
  if (params === void 0) {
    params = {};
  }

  if (options === void 0) {
    options = {};
  }

  var _a = options.queryParamsMode,
      queryParamsMode = _a === void 0 ? 'default' : _a,
      _b = options.trailingSlashMode,
      trailingSlashMode = _b === void 0 ? 'default' : _b;
  var searchParams = [];
  var nonSearchParams = [];

  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
    var segment = segments_1[_i];
    var parser = segment.parser;

    if (parser) {
      searchParams.push.apply(searchParams, parser.queryParams);
      nonSearchParams.push.apply(nonSearchParams, parser.urlParams);
      nonSearchParams.push.apply(nonSearchParams, parser.spatParams);
    }
  }

  if (queryParamsMode === 'loose') {
    var extraParams = Object.keys(params).reduce(function (acc, p) {
      return searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1 ? acc.concat(p) : acc;
    }, []);
    searchParams.push.apply(searchParams, extraParams);
  }

  var searchParamsObject = searchParams.reduce(function (acc, paramName) {
    if (Object.keys(params).indexOf(paramName) !== -1) {
      acc[paramName] = params[paramName];
    }

    return acc;
  }, {});
  var searchPart = (0,search_params__WEBPACK_IMPORTED_MODULE_0__.build)(searchParamsObject, options.queryParams);
  var path = segments.reduce(function (path, segment) {
    var _a, _b;

    var segmentPath = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.build(params, {
      ignoreSearch: true,
      queryParams: options.queryParams,
      urlParamsEncoding: options.urlParamsEncoding
    }), _b !== null && _b !== void 0 ? _b : '');
    return segment.absolute ? segmentPath : path + segmentPath;
  }, '') // remove repeated slashes
  .replace(/\/\/{1,}/g, '/');
  var finalPath = path;

  if (trailingSlashMode === 'always') {
    finalPath = /\/$/.test(path) ? path : path + "/";
  } else if (trailingSlashMode === 'never' && path !== '/') {
    finalPath = /\/$/.test(path) ? path.slice(0, -1) : path;
  }

  return finalPath + (searchPart ? '?' + searchPart : '');
};
var getPathFromSegments = function getPathFromSegments(segments) {
  return segments ? segments.map(function (segment) {
    return segment.path;
  }).join('') : null;
};

var getPath = function getPath(path) {
  return path.split('?')[0];
};

var getSearch = function getSearch(path) {
  return path.split('?')[1] || '';
};

var matchChildren = function matchChildren(nodes, pathSegment, currentMatch, options, consumedBefore) {
  if (options === void 0) {
    options = {};
  }

  var _a = options.queryParamsMode,
      queryParamsMode = _a === void 0 ? 'default' : _a,
      _b = options.strictTrailingSlash,
      strictTrailingSlash = _b === void 0 ? false : _b,
      _c = options.strongMatching,
      strongMatching = _c === void 0 ? true : _c,
      _d = options.caseSensitive,
      caseSensitive = _d === void 0 ? false : _d;
  var isRoot = nodes.length === 1 && nodes[0].name === '';

  var _loop_1 = function _loop_1(child) {
    // Partially match path
    var match = null;
    var remainingPath = void 0;
    var segment = pathSegment;

    if (consumedBefore === '/' && child.path === '/') {
      // when we encounter repeating slashes we add the slash
      // back to the URL to make it de facto pathless
      segment = '/' + pathSegment;
    }

    if (!child.children.length) {
      match = child.parser.test(segment, {
        caseSensitive: caseSensitive,
        strictTrailingSlash: strictTrailingSlash,
        queryParams: options.queryParams,
        urlParamsEncoding: options.urlParamsEncoding
      });
    }

    if (!match) {
      match = child.parser.partialTest(segment, {
        delimited: strongMatching,
        caseSensitive: caseSensitive,
        queryParams: options.queryParams,
        urlParamsEncoding: options.urlParamsEncoding
      });
    }

    if (match) {
      // Remove consumed segment from path
      var consumedPath = child.parser.build(match, {
        ignoreSearch: true,
        urlParamsEncoding: options.urlParamsEncoding
      });

      if (!strictTrailingSlash && !child.children.length) {
        consumedPath = consumedPath.replace(/\/$/, '');
      } // Can't create a regexp from the path because it might contain a
      // regexp character.


      if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {
        remainingPath = segment.slice(consumedPath.length);
      } else {
        remainingPath = segment;
      }

      if (!strictTrailingSlash && !child.children.length) {
        remainingPath = remainingPath.replace(/^\/\?/, '?');
      }

      var querystring = (0,search_params__WEBPACK_IMPORTED_MODULE_0__.omit)(getSearch(segment.replace(consumedPath, '')), child.parser.queryParams, options.queryParams).querystring;
      remainingPath = getPath(remainingPath) + (querystring ? "?" + querystring : '');

      if (!strictTrailingSlash && !isRoot && remainingPath === '/' && !/\/$/.test(consumedPath)) {
        remainingPath = '';
      }

      currentMatch.segments.push(child);
      Object.keys(match).forEach(function (param) {
        return currentMatch.params[param] = match[param];
      });

      if (!isRoot && !remainingPath.length) {
        return {
          value: currentMatch
        };
      }

      if (!isRoot && queryParamsMode !== 'strict' && remainingPath.indexOf('?') === 0) {
        // unmatched queryParams in non strict mode
        var remainingQueryParams_1 = (0,search_params__WEBPACK_IMPORTED_MODULE_0__.parse)(remainingPath.slice(1), options.queryParams);
        Object.keys(remainingQueryParams_1).forEach(function (name) {
          return currentMatch.params[name] = remainingQueryParams_1[name];
        });
        return {
          value: currentMatch
        };
      } // Continue matching on non absolute children


      var children = child.getNonAbsoluteChildren(); // If no children to match against but unmatched path left

      if (!children.length) {
        return {
          value: null
        };
      }

      return {
        value: matchChildren(children, remainingPath, currentMatch, options, consumedPath)
      };
    }
  }; // for (child of node.children) {


  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var child = nodes_1[_i];

    var state_1 = _loop_1(child);

    if (typeof state_1 === "object") return state_1.value;
  }

  return null;
};

function sortChildren(children) {
  var originalChildren = children.slice(0);
  return children.sort(sortPredicate(originalChildren));
}

var sortPredicate = function sortPredicate(originalChildren) {
  return function (left, right) {
    var _a, _b, _c, _d, _e, _f;

    var leftPath = left.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\/$/, '$1');
    var rightPath = right.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\/$/, '$1'); // '/' last

    if (leftPath === '/') {
      return 1;
    }

    if (rightPath === '/') {
      return -1;
    } // Spat params last


    if ((_a = left.parser) === null || _a === void 0 ? void 0 : _a.hasSpatParam) {
      return 1;
    }

    if ((_b = right.parser) === null || _b === void 0 ? void 0 : _b.hasSpatParam) {
      return -1;
    } // No spat, number of segments (less segments last)


    var leftSegments = (leftPath.match(/\//g) || []).length;
    var rightSegments = (rightPath.match(/\//g) || []).length;

    if (leftSegments < rightSegments) {
      return 1;
    }

    if (leftSegments > rightSegments) {
      return -1;
    } // Same number of segments, number of URL params ascending


    var leftParamsCount = (_d = (_c = left.parser) === null || _c === void 0 ? void 0 : _c.urlParams.length, _d !== null && _d !== void 0 ? _d : 0);
    var rightParamsCount = (_f = (_e = right.parser) === null || _e === void 0 ? void 0 : _e.urlParams.length, _f !== null && _f !== void 0 ? _f : 0);

    if (leftParamsCount < rightParamsCount) {
      return -1;
    }

    if (leftParamsCount > rightParamsCount) {
      return 1;
    } // Same number of segments and params, last segment length descending


    var leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length;
    var rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length;

    if (leftParamLength < rightParamLength) {
      return 1;
    }

    if (leftParamLength > rightParamLength) {
      return -1;
    } // Same last segment length, preserve definition order. Note that we
    // cannot just return 0, as sort is not guaranteed to be a stable sort.


    return originalChildren.indexOf(left) - originalChildren.indexOf(right);
  };
};

var RouteNode =
/*#__PURE__*/

/** @class */
function () {
  function RouteNode(name, path, childRoutes, options) {
    if (name === void 0) {
      name = '';
    }

    if (path === void 0) {
      path = '';
    }

    if (childRoutes === void 0) {
      childRoutes = [];
    }

    if (options === void 0) {
      options = {};
    }

    this.name = name;
    this.absolute = /^~/.test(path);
    this.path = this.absolute ? path.slice(1) : path;
    this.parser = this.path ? new path_parser__WEBPACK_IMPORTED_MODULE_1__.Path(this.path) : null;
    this.children = [];
    this.parent = options.parent;
    this.checkParents();
    this.add(childRoutes, options.onAdd, options.finalSort ? false : options.sort !== false);

    if (options.finalSort) {
      this.sortDescendants();
    }

    return this;
  }

  RouteNode.prototype.getParentSegments = function (segments) {
    if (segments === void 0) {
      segments = [];
    }

    return this.parent && this.parent.parser ? this.parent.getParentSegments(segments.concat(this.parent)) : segments.reverse();
  };

  RouteNode.prototype.setParent = function (parent) {
    this.parent = parent;
    this.checkParents();
  };

  RouteNode.prototype.setPath = function (path) {
    if (path === void 0) {
      path = '';
    }

    this.path = path;
    this.parser = path ? new path_parser__WEBPACK_IMPORTED_MODULE_1__.Path(path) : null;
  };

  RouteNode.prototype.add = function (route, cb, sort) {
    var _this = this;

    if (sort === void 0) {
      sort = true;
    }

    if (route === undefined || route === null) {
      return this;
    }

    if (route instanceof Array) {
      route.forEach(function (r) {
        return _this.add(r, cb, sort);
      });
      return this;
    }

    if (!(route instanceof RouteNode) && !(route instanceof Object)) {
      throw new Error('RouteNode.add() expects routes to be an Object or an instance of RouteNode.');
    } else if (route instanceof RouteNode) {
      route.setParent(this);
      this.addRouteNode(route, sort);
    } else {
      if (!route.name || !route.path) {
        throw new Error('RouteNode.add() expects routes to have a name and a path defined.');
      }

      var routeNode = new RouteNode(route.name, route.path, route.children, {
        finalSort: false,
        onAdd: cb,
        parent: this,
        sort: sort
      });
      var fullName = routeNode.getParentSegments([routeNode]).map(function (_) {
        return _.name;
      }).join('.');

      if (cb) {
        cb((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, route), {
          name: fullName
        }));
      }

      this.addRouteNode(routeNode, sort);
    }

    return this;
  };

  RouteNode.prototype.addNode = function (name, path) {
    this.add(new RouteNode(name, path));
    return this;
  };

  RouteNode.prototype.getPath = function (routeName) {
    var segmentsByName = this.getSegmentsByName(routeName);
    return segmentsByName ? getPathFromSegments(segmentsByName) : null;
  };

  RouteNode.prototype.getNonAbsoluteChildren = function () {
    return this.children.filter(function (child) {
      return !child.absolute;
    });
  };

  RouteNode.prototype.sortChildren = function () {
    if (this.children.length) {
      sortChildren(this.children);
    }
  };

  RouteNode.prototype.sortDescendants = function () {
    this.sortChildren();
    this.children.forEach(function (child) {
      return child.sortDescendants();
    });
  };

  RouteNode.prototype.buildPath = function (routeName, params, options) {
    if (params === void 0) {
      params = {};
    }

    if (options === void 0) {
      options = {};
    }

    var segments = this.getSegmentsByName(routeName);

    if (!segments) {
      throw new Error("[route-node][buildPath] '{routeName}' is not defined");
    }

    return buildPathFromSegments(segments, params, options);
  };

  RouteNode.prototype.buildState = function (name, params) {
    if (params === void 0) {
      params = {};
    }

    var segments = this.getSegmentsByName(name);

    if (!segments || !segments.length) {
      return null;
    }

    return {
      name: name,
      params: params,
      meta: getMetaFromSegments(segments)
    };
  };

  RouteNode.prototype.matchPath = function (path, options) {
    if (options === void 0) {
      options = {};
    }

    if (path === '' && !options.strictTrailingSlash) {
      path = '/';
    }

    var match = this.getSegmentsMatchingPath(path, options);

    if (!match) {
      return null;
    }

    var matchedSegments = match.segments;

    if (matchedSegments[0].absolute) {
      var firstSegmentParams = matchedSegments[0].getParentSegments();
      matchedSegments.reverse();
      matchedSegments.push.apply(matchedSegments, firstSegmentParams);
      matchedSegments.reverse();
    }

    var lastSegment = matchedSegments[matchedSegments.length - 1];
    var lastSegmentSlashChild = lastSegment.findSlashChild();

    if (lastSegmentSlashChild) {
      matchedSegments.push(lastSegmentSlashChild);
    }

    return buildStateFromMatch(match);
  };

  RouteNode.prototype.addRouteNode = function (route, sort) {
    if (sort === void 0) {
      sort = true;
    }

    var names = route.name.split('.');

    if (names.length === 1) {
      // Check duplicated routes
      if (this.children.map(function (child) {
        return child.name;
      }).indexOf(route.name) !== -1) {
        throw new Error("Alias \"" + route.name + "\" is already defined in route node");
      } // Check duplicated paths


      if (this.children.map(function (child) {
        return child.path;
      }).indexOf(route.path) !== -1) {
        throw new Error("Path \"" + route.path + "\" is already defined in route node");
      }

      this.children.push(route);

      if (sort) {
        this.sortChildren();
      }
    } else {
      // Locate parent node
      var segments = this.getSegmentsByName(names.slice(0, -1).join('.'));

      if (segments) {
        route.name = names[names.length - 1];
        segments[segments.length - 1].add(route);
      } else {
        throw new Error("Could not add route named '" + route.name + "', parent is missing.");
      }
    }

    return this;
  };

  RouteNode.prototype.checkParents = function () {
    if (this.absolute && this.hasParentsParams()) {
      throw new Error('[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters');
    }
  };

  RouteNode.prototype.hasParentsParams = function () {
    if (this.parent && this.parent.parser) {
      var parser = this.parent.parser;
      var hasParams = parser.hasUrlParams || parser.hasSpatParam || parser.hasMatrixParams || parser.hasQueryParams;
      return hasParams || this.parent.hasParentsParams();
    }

    return false;
  };

  RouteNode.prototype.findAbsoluteChildren = function () {
    return this.children.reduce(function (absoluteChildren, child) {
      return absoluteChildren.concat(child.absolute ? child : []).concat(child.findAbsoluteChildren());
    }, []);
  };

  RouteNode.prototype.findSlashChild = function () {
    var slashChildren = this.getNonAbsoluteChildren().filter(function (child) {
      return child.parser && /^\/(\?|$)/.test(child.parser.path);
    });
    return slashChildren[0];
  };

  RouteNode.prototype.getSegmentsByName = function (routeName) {
    var findSegmentByName = function findSegmentByName(name, routes) {
      var filteredRoutes = routes.filter(function (r) {
        return r.name === name;
      });
      return filteredRoutes.length ? filteredRoutes[0] : undefined;
    };

    var segments = [];
    var routes = this.parser ? [this] : this.children;
    var names = (this.parser ? [''] : []).concat(routeName.split('.'));
    var matched = names.every(function (name) {
      var segment = findSegmentByName(name, routes);

      if (segment) {
        routes = segment.children;
        segments.push(segment);
        return true;
      }

      return false;
    });
    return matched ? segments : null;
  };

  RouteNode.prototype.getSegmentsMatchingPath = function (path, options) {
    var topLevelNodes = this.parser ? [this] : this.children;
    var startingNodes = topLevelNodes.reduce(function (nodes, node) {
      return nodes.concat(node, node.findAbsoluteChildren());
    }, []);
    var currentMatch = {
      segments: [],
      params: {}
    };
    var finalMatch = matchChildren(startingNodes, path, currentMatch, options);

    if (finalMatch && finalMatch.segments.length === 1 && finalMatch.segments[0].name === '') {
      return null;
    }

    return finalMatch;
  };

  return RouteNode;
}();


//# sourceMappingURL=route-node.esm.js.map


/***/ }),

/***/ "./node_modules/router5-plugin-browser/dist/index.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/router5-plugin-browser/dist/index.es.js ***!
  \**************************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var router5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! router5 */ "./node_modules/router5/dist/index.es.js");
;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var value = function (arg) { return function () { return arg; }; };
var noop = function () { };
var isBrowser = typeof window !== 'undefined' && window.history;
var getBase = function () { return window.location.pathname; };
var supportsPopStateOnHashChange = function () {
    return window.navigator.userAgent.indexOf('Trident') === -1;
};
var pushState = function (state, title, path) {
    return window.history.pushState(state, title, path);
};
var replaceState = function (state, title, path) {
    return window.history.replaceState(state, title, path);
};
var addPopstateListener = function (fn, opts) {
    var shouldAddHashChangeListener = opts.useHash && !supportsPopStateOnHashChange();
    window.addEventListener('popstate', fn);
    if (shouldAddHashChangeListener) {
        window.addEventListener('hashchange', fn);
    }
    return function () {
        window.removeEventListener('popstate', fn);
        if (shouldAddHashChangeListener) {
            window.removeEventListener('hashchange', fn);
        }
    };
};
var getLocation = function (opts) {
    var path = opts.useHash
        ? window.location.hash.replace(new RegExp('^#' + opts.hashPrefix), '')
        : window.location.pathname.replace(new RegExp('^' + opts.base), '');
    // Fix issue with browsers that don't URL encode characters (Edge)
    var correctedPath = safelyEncodePath(path);
    return (correctedPath || '/') + window.location.search;
};
var safelyEncodePath = function (path) {
    try {
        return encodeURI(decodeURI(path));
    }
    catch (_) {
        return path;
    }
};
var getState = function () { return window.history.state; };
var getHash = function () { return window.location.hash; };
var browser = {};
if (isBrowser) {
    browser = {
        getBase: getBase,
        pushState: pushState,
        replaceState: replaceState,
        addPopstateListener: addPopstateListener,
        getLocation: getLocation,
        getState: getState,
        getHash: getHash
    };
}
else {
    browser = {
        getBase: value(''),
        pushState: noop,
        replaceState: noop,
        addPopstateListener: noop,
        getLocation: value(''),
        getState: value(null),
        getHash: value('')
    };
}
var safeBrowser = browser;

var defaultOptions = {
    forceDeactivate: true,
    useHash: false,
    hashPrefix: '',
    base: '',
    mergeState: false,
    preserveHash: true
};
var source = 'popstate';
function browserPluginFactory(opts, browser) {
    if (browser === void 0) { browser = safeBrowser; }
    var options = __assign(__assign({}, defaultOptions), opts);
    var transitionOptions = {
        forceDeactivate: options.forceDeactivate,
        source: source
    };
    var removePopStateListener;
    return function browserPlugin(router) {
        var routerOptions = router.getOptions();
        var routerStart = router.start;
        router.buildUrl = function (route, params) {
            var base = options.base || '';
            var prefix = options.useHash ? "#" + options.hashPrefix : '';
            var path = router.buildPath(route, params);
            return base + prefix + path;
        };
        var urlToPath = function (url) {
            var match = url.match(/^(?:http|https):\/\/(?:[0-9a-z_\-.:]+?)(?=\/)(.*)$/);
            var path = match ? match[1] : url;
            var pathParts = path.match(/^(.+?)(#.+?)?(\?.+)?$/);
            if (!pathParts)
                throw new Error("[router5] Could not parse url " + url);
            var pathname = pathParts[1];
            var hash = pathParts[2] || '';
            var search = pathParts[3] || '';
            return ((options.useHash
                ? hash.replace(new RegExp('^#' + options.hashPrefix), '')
                : options.base
                    ? pathname.replace(new RegExp('^' + options.base), '')
                    : pathname) + search);
        };
        router.matchUrl = function (url) { return router.matchPath(urlToPath(url)); };
        router.start = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length === 0 || typeof args[0] === 'function') {
                routerStart.apply(void 0, __spreadArrays([browser.getLocation(options)], args));
            }
            else {
                routerStart.apply(void 0, args);
            }
            return router;
        };
        router.replaceHistoryState = function (name, params, title) {
            if (params === void 0) { params = {}; }
            if (title === void 0) { title = ''; }
            var route = router.buildState(name, params);
            var state = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta });
            var url = router.buildUrl(name, params);
            router.lastKnownState = state;
            browser.replaceState(state, title, url);
        };
        function updateBrowserState(state, url, replace) {
            var trimmedState = state
                ? {
                    meta: state.meta,
                    name: state.name,
                    params: state.params,
                    path: state.path
                }
                : state;
            var finalState = options.mergeState === true
                ? __assign(__assign({}, browser.getState()), trimmedState) : trimmedState;
            if (replace)
                browser.replaceState(finalState, '', url);
            else
                browser.pushState(finalState, '', url);
        }
        function onPopState(evt) {
            var routerState = router.getState();
            // Do nothing if no state or if last know state is poped state (it should never happen)
            var newState = !evt.state || !evt.state.name;
            var state = newState
                ? router.matchPath(browser.getLocation(options), source)
                : router.makeState(evt.state.name, evt.state.params, evt.state.path, __assign(__assign({}, evt.state.meta), { source: source }), evt.state.meta.id);
            var defaultRoute = routerOptions.defaultRoute, defaultParams = routerOptions.defaultParams;
            if (!state) {
                // If current state is already the default route, we will have a double entry
                // Navigating back and forth will emit SAME_STATES error
                defaultRoute &&
                    router.navigateToDefault(__assign(__assign({}, transitionOptions), { reload: true, replace: true }));
                return;
            }
            if (routerState &&
                router.areStatesEqual(state, routerState, false)) {
                return;
            }
            router.transitionToState(state, routerState, transitionOptions, function (err, toState) {
                if (err) {
                    if (err.redirect) {
                        var _a = err.redirect, name_1 = _a.name, params = _a.params;
                        router.navigate(name_1, params, __assign(__assign({}, transitionOptions), { replace: true, force: true, redirected: true }));
                    }
                    else if (err.code === router5__WEBPACK_IMPORTED_MODULE_0__.errorCodes.CANNOT_DEACTIVATE) {
                        var url = router.buildUrl(routerState.name, routerState.params);
                        if (!newState) {
                            // Keep history state unchanged but use current URL
                            updateBrowserState(state, url, true);
                        }
                        // else do nothing or history will be messed up
                        // TODO: history.back()?
                    }
                    else {
                        // Force navigation to default state
                        defaultRoute &&
                            router.navigate(defaultRoute, defaultParams, __assign(__assign({}, transitionOptions), { reload: true, replace: true }));
                    }
                }
                else {
                    router.invokeEventListeners(router5__WEBPACK_IMPORTED_MODULE_0__.constants.TRANSITION_SUCCESS, toState, routerState, { replace: true });
                }
            });
        }
        function onStart() {
            if (options.useHash && !options.base) {
                // Guess base
                options.base = browser.getBase();
            }
            removePopStateListener = browser.addPopstateListener(onPopState, options);
        }
        function teardown() {
            if (removePopStateListener) {
                removePopStateListener();
                removePopStateListener = undefined;
            }
        }
        function onTransitionSuccess(toState, fromState, opts) {
            var historyState = browser.getState();
            var hasState = historyState &&
                historyState.meta &&
                historyState.name &&
                historyState.params;
            var statesAreEqual = fromState && router.areStatesEqual(fromState, toState, false);
            var replace = opts.replace || !hasState || statesAreEqual;
            var url = router.buildUrl(toState.name, toState.params);
            if (fromState === null &&
                options.useHash === false &&
                options.preserveHash === true) {
                url += browser.getHash();
            }
            updateBrowserState(toState, url, replace);
        }
        return {
            onStart: onStart,
            onStop: teardown,
            teardown: teardown,
            onTransitionSuccess: onTransitionSuccess,
            onPopState: onPopState
        };
    };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (browserPluginFactory);


/***/ }),

/***/ "./node_modules/router5-transition-path/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/router5-transition-path/dist/index.es.js ***!
  \***************************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! export nameToIDs [provided] [no usage info] [missing usage info prevents renaming] */
/*! export shouldUpdateNode [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "nameToIDs": () => /* binding */ nameToIDs,
/* harmony export */   "shouldUpdateNode": () => /* binding */ shouldUpdateNode
/* harmony export */ });
var nameToIDs = function (name) {
    return name
        .split('.')
        .reduce(function (ids, name) {
        return ids.concat(ids.length ? ids[ids.length - 1] + '.' + name : name);
    }, []);
};
var exists = function (val) { return val !== undefined && val !== null; };
var hasMetaParams = function (state) { return state && state.meta && state.meta.params; };
var extractSegmentParams = function (name, state) {
    if (!hasMetaParams(state) || !exists(state.meta.params[name]))
        return {};
    return Object.keys(state.meta.params[name]).reduce(function (params, p) {
        params[p] = state.params[p];
        return params;
    }, {});
};
function transitionPath(toState, fromState) {
    var toStateOptions = (toState.meta && toState.meta && toState.meta.options) || {};
    var fromStateIds = fromState ? nameToIDs(fromState.name) : [];
    var toStateIds = nameToIDs(toState.name);
    var maxI = Math.min(fromStateIds.length, toStateIds.length);
    function pointOfDifference() {
        var i;
        var _loop_1 = function () {
            var left = fromStateIds[i];
            var right = toStateIds[i];
            if (left !== right)
                return { value: i };
            var leftParams = extractSegmentParams(left, toState);
            var rightParams = extractSegmentParams(right, fromState);
            if (Object.keys(leftParams).length !==
                Object.keys(rightParams).length)
                return { value: i };
            if (Object.keys(leftParams).length === 0)
                return "continue";
            var different = Object.keys(leftParams).some(function (p) { return rightParams[p] !== leftParams[p]; });
            if (different) {
                return { value: i };
            }
        };
        for (i = 0; i < maxI; i += 1) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return i;
    }
    var i;
    if (!fromState || toStateOptions.reload) {
        i = 0;
    }
    else if (!hasMetaParams(fromState) && !hasMetaParams(toState)) {
        i = 0;
    }
    else {
        i = pointOfDifference();
    }
    var toDeactivate = fromStateIds.slice(i).reverse();
    var toActivate = toStateIds.slice(i);
    var intersection = fromState && i > 0 ? fromStateIds[i - 1] : '';
    return {
        intersection: intersection,
        toDeactivate: toDeactivate,
        toActivate: toActivate
    };
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function shouldUpdateNode(nodeName) {
    return function (toState, fromSate) {
        var _a = transitionPath(toState, fromSate), intersection = _a.intersection, toActivate = _a.toActivate, toDeactivateReversed = _a.toDeactivate;
        var toDeactivate = __spreadArrays(toDeactivateReversed).reverse();
        if (toState.meta.options && toState.meta.options.reload) {
            return true;
        }
        if (nodeName === intersection) {
            return true;
        }
        if (toActivate.indexOf(nodeName) === -1) {
            return false;
        }
        var matching = true;
        for (var i = 0; i < toActivate.length; i += 1) {
            var activatedSegment = toActivate[i];
            var sameLevelDeactivatedSegment = toDeactivate[i];
            matching = activatedSegment === sameLevelDeactivatedSegment;
            if (matching && activatedSegment === nodeName) {
                return true;
            }
            if (!matching) {
                return false;
            }
        }
        return false;
    };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (transitionPath);



/***/ }),

/***/ "./node_modules/router5/dist/index.es.js":
/*!***********************************************!*\
  !*** ./node_modules/router5/dist/index.es.js ***!
  \***********************************************/
/*! namespace exports */
/*! export RouteNode [provided] [no usage info] [missing usage info prevents renaming] -> ./node_modules/route-node/dist/route-node.esm.js .RouteNode */
/*! export cloneRouter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export constants [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createRouter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! export errorCodes [provided] [no usage info] [missing usage info prevents renaming] */
/*! export transitionPath [provided] [no usage info] [missing usage info prevents renaming] -> ./node_modules/router5-transition-path/dist/index.es.js .default */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_exports__, __webpack_require__.d, __webpack_require__.r, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouteNode": () => /* reexport safe */ route_node__WEBPACK_IMPORTED_MODULE_0__.RouteNode,
/* harmony export */   "transitionPath": () => /* reexport safe */ router5_transition_path__WEBPACK_IMPORTED_MODULE_2__.default,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "cloneRouter": () => /* binding */ cloneRouter,
/* harmony export */   "constants": () => /* binding */ constants,
/* harmony export */   "createRouter": () => /* binding */ createRouter,
/* harmony export */   "errorCodes": () => /* binding */ errorCodes
/* harmony export */ });
/* harmony import */ var route_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! route-node */ "./node_modules/route-node/dist/route-node.esm.js");
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/es/index.js");
/* harmony import */ var router5_transition_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! router5-transition-path */ "./node_modules/router5-transition-path/dist/index.es.js");
;





/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var defaultOptions = {
    trailingSlashMode: 'default',
    queryParamsMode: 'default',
    strictTrailingSlash: false,
    autoCleanUp: true,
    allowNotFound: false,
    strongMatching: true,
    rewritePathOnMatch: true,
    caseSensitive: false,
    urlParamsEncoding: 'default'
};
function withOptions(options) {
    return function (router) {
        var routerOptions = __assign(__assign({}, defaultOptions), options);
        router.getOptions = function () { return routerOptions; };
        router.setOption = function (option, value) {
            routerOptions[option] = value;
            return router;
        };
        return router;
    };
}

var errorCodes = {
    ROUTER_NOT_STARTED: 'NOT_STARTED',
    NO_START_PATH_OR_STATE: 'NO_START_PATH_OR_STATE',
    ROUTER_ALREADY_STARTED: 'ALREADY_STARTED',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND',
    SAME_STATES: 'SAME_STATES',
    CANNOT_DEACTIVATE: 'CANNOT_DEACTIVATE',
    CANNOT_ACTIVATE: 'CANNOT_ACTIVATE',
    TRANSITION_ERR: 'TRANSITION_ERR',
    TRANSITION_CANCELLED: 'CANCELLED'
};
var constants = {
    UNKNOWN_ROUTE: '@@router5/UNKNOWN_ROUTE',
    ROUTER_START: '$start',
    ROUTER_STOP: '$stop',
    TRANSITION_START: '$$start',
    TRANSITION_CANCEL: '$$cancel',
    TRANSITION_SUCCESS: '$$success',
    TRANSITION_ERROR: '$$error'
};

function withRoutes(routes) {
    return function (router) {
        router.forward = function (fromRoute, toRoute) {
            router.config.forwardMap[fromRoute] = toRoute;
            return router;
        };
        var rootNode = routes instanceof route_node__WEBPACK_IMPORTED_MODULE_0__.RouteNode
            ? routes
            : new route_node__WEBPACK_IMPORTED_MODULE_0__.RouteNode('', '', routes, { onAdd: onRouteAdded });
        function onRouteAdded(route) {
            if (route.canActivate)
                router.canActivate(route.name, route.canActivate);
            if (route.forwardTo)
                router.forward(route.name, route.forwardTo);
            if (route.decodeParams)
                router.config.decoders[route.name] = route.decodeParams;
            if (route.encodeParams)
                router.config.encoders[route.name] = route.encodeParams;
            if (route.defaultParams)
                router.config.defaultParams[route.name] = route.defaultParams;
        }
        router.rootNode = rootNode;
        router.add = function (routes, finalSort) {
            rootNode.add(routes, onRouteAdded, !finalSort);
            if (finalSort) {
                rootNode.sortDescendants();
            }
            return router;
        };
        router.addNode = function (name, path, canActivateHandler) {
            rootNode.addNode(name, path);
            if (canActivateHandler)
                router.canActivate(name, canActivateHandler);
            return router;
        };
        router.isActive = function (name, params, strictEquality, ignoreQueryParams) {
            if (params === void 0) { params = {}; }
            if (strictEquality === void 0) { strictEquality = false; }
            if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
            var activeState = router.getState();
            if (!activeState)
                return false;
            if (strictEquality || activeState.name === name) {
                return router.areStatesEqual(router.makeState(name, params), activeState, ignoreQueryParams);
            }
            return router.areStatesDescendants(router.makeState(name, params), activeState);
        };
        router.buildPath = function (route, params) {
            if (route === constants.UNKNOWN_ROUTE) {
                return params.path;
            }
            var paramsWithDefault = __assign(__assign({}, router.config.defaultParams[route]), params);
            var _a = router.getOptions(), trailingSlashMode = _a.trailingSlashMode, queryParamsMode = _a.queryParamsMode, queryParams = _a.queryParams;
            var encodedParams = router.config.encoders[route]
                ? router.config.encoders[route](paramsWithDefault)
                : paramsWithDefault;
            return router.rootNode.buildPath(route, encodedParams, {
                trailingSlashMode: trailingSlashMode,
                queryParamsMode: queryParamsMode,
                queryParams: queryParams,
                urlParamsEncoding: router.getOptions().urlParamsEncoding
            });
        };
        router.matchPath = function (path, source) {
            var options = router.getOptions();
            var match = router.rootNode.matchPath(path, options);
            if (match) {
                var name_1 = match.name, params = match.params, meta = match.meta;
                var decodedParams = router.config.decoders[name_1]
                    ? router.config.decoders[name_1](params)
                    : params;
                var _a = router.forwardState(name_1, decodedParams), routeName = _a.name, routeParams = _a.params;
                var builtPath = options.rewritePathOnMatch === false
                    ? path
                    : router.buildPath(routeName, routeParams);
                return router.makeState(routeName, routeParams, builtPath, {
                    params: meta,
                    source: source
                });
            }
            return null;
        };
        router.setRootPath = function (rootPath) {
            router.rootNode.setPath(rootPath);
        };
        return router;
    };
}

function withDependencies(dependencies) {
    return function (router) {
        var routerDependencies = dependencies;
        router.setDependency = function (dependencyName, dependency) {
            routerDependencies[dependencyName] = dependency;
            return router;
        };
        router.setDependencies = function (deps) {
            Object.keys(deps).forEach(function (name) {
                return router.setDependency(name, deps[name]);
            });
            return router;
        };
        router.getDependencies = function () { return routerDependencies; };
        router.getInjectables = function () { return [router, router.getDependencies()]; };
        router.executeFactory = function (factoryFunction) {
            return factoryFunction.apply(void 0, router.getInjectables());
        };
        return router;
    };
}

function withState(router) {
    var stateId = 0;
    var routerState = null;
    router.getState = function () { return routerState; };
    router.setState = function (state) {
        routerState = state;
    };
    router.makeState = function (name, params, path, meta, forceId) { return ({
        name: name,
        params: __assign(__assign({}, router.config.defaultParams[name]), params),
        path: path,
        meta: meta
            ? __assign(__assign({}, meta), { id: forceId === undefined ? ++stateId : forceId }) : undefined
    }); };
    router.makeNotFoundState = function (path, options) {
        return router.makeState(constants.UNKNOWN_ROUTE, { path: path }, path, {
            options: options
        });
    };
    router.areStatesEqual = function (state1, state2, ignoreQueryParams) {
        if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
        if (state1.name !== state2.name)
            return false;
        var getUrlParams = function (name) {
            return router.rootNode
                //@ts-ignore
                .getSegmentsByName(name)
                .map(function (segment) { return segment.parser['urlParams']; })
                .reduce(function (params, p) { return params.concat(p); }, []);
        };
        var state1Params = ignoreQueryParams
            ? getUrlParams(state1.name)
            : Object.keys(state1.params);
        var state2Params = ignoreQueryParams
            ? getUrlParams(state2.name)
            : Object.keys(state2.params);
        return (state1Params.length === state2Params.length &&
            state1Params.every(function (p) { return state1.params[p] === state2.params[p]; }));
    };
    router.areStatesDescendants = function (parentState, childState) {
        var regex = new RegExp('^' + parentState.name + '\\.(.*)$');
        if (!regex.test(childState.name))
            return false;
        // If child state name extends parent state name, and all parent state params
        // are in child state params.
        return Object.keys(parentState.params).every(function (p) { return parentState.params[p] === childState.params[p]; });
    };
    router.forwardState = function (routeName, routeParams) {
        var name = router.config.forwardMap[routeName] || routeName;
        var params = __assign(__assign(__assign({}, router.config.defaultParams[routeName]), router.config.defaultParams[name]), routeParams);
        return {
            name: name,
            params: params
        };
    };
    router.buildState = function (routeName, routeParams) {
        var _a = router.forwardState(routeName, routeParams), name = _a.name, params = _a.params;
        return router.rootNode.buildState(name, params);
    };
    return router;
}

var eventsMap = {
    onStart: constants.ROUTER_START,
    onStop: constants.ROUTER_STOP,
    onTransitionSuccess: constants.TRANSITION_SUCCESS,
    onTransitionStart: constants.TRANSITION_START,
    onTransitionError: constants.TRANSITION_ERROR,
    onTransitionCancel: constants.TRANSITION_CANCEL
};
function withPlugins(router) {
    var routerPlugins = [];
    router.getPlugins = function () { return routerPlugins; };
    router.usePlugin = function () {
        var plugins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            plugins[_i] = arguments[_i];
        }
        var removePluginFns = plugins.map(function (plugin) {
            routerPlugins.push(plugin);
            return startPlugin(plugin);
        });
        return function () {
            routerPlugins = routerPlugins.filter(function (plugin) { return plugins.indexOf(plugin) === -1; });
            removePluginFns.forEach(function (removePlugin) { return removePlugin(); });
        };
    };
    function startPlugin(plugin) {
        var appliedPlugin = router.executeFactory(plugin);
        var removeEventListeners = Object.keys(eventsMap)
            .map(function (methodName) {
            if (appliedPlugin[methodName]) {
                return router.addEventListener(eventsMap[methodName], appliedPlugin[methodName]);
            }
        })
            .filter(Boolean);
        return function () {
            removeEventListeners.forEach(function (removeListener) { return removeListener(); });
            if (appliedPlugin.teardown) {
                appliedPlugin.teardown();
            }
        };
    }
    return router;
}

function withMiddleware(router) {
    var middlewareFactories = [];
    var middlewareFunctions = [];
    router.useMiddleware = function () {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
        }
        var removePluginFns = middlewares.map(function (middleware) {
            var middlewareFunction = router.executeFactory(middleware);
            middlewareFactories.push(middleware);
            middlewareFunctions.push(middlewareFunction);
            return function () {
                middlewareFactories = middlewareFactories.filter(function (m) { return m !== middleware; });
                middlewareFunctions = middlewareFunctions.filter(function (m) { return m !== middlewareFunction; });
            };
        });
        return function () { return removePluginFns.forEach(function (fn) { return fn(); }); };
    };
    router.clearMiddleware = function () {
        middlewareFactories = [];
        middlewareFunctions = [];
        return router;
    };
    router.getMiddlewareFactories = function () { return middlewareFactories; };
    router.getMiddlewareFunctions = function () { return middlewareFunctions; };
    return router;
}

function withObservability(router) {
    var callbacks = {};
    router.invokeEventListeners = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (callbacks[eventName] || []).forEach(function (cb) { return cb.apply(void 0, args); });
    };
    router.removeEventListener = function (eventName, cb) {
        callbacks[eventName] = callbacks[eventName].filter(function (_cb) { return _cb !== cb; });
    };
    router.addEventListener = function (eventName, cb) {
        callbacks[eventName] = (callbacks[eventName] || []).concat(cb);
        return function () { return router.removeEventListener(eventName, cb); };
    };
    function subscribe(listener) {
        var isObject = typeof listener === 'object';
        var finalListener = isObject ? listener.next.bind(listener) : listener;
        var unsubscribeHandler = router.addEventListener(constants.TRANSITION_SUCCESS, function (toState, fromState) {
            finalListener({
                route: toState,
                previousRoute: fromState
            });
        });
        return isObject
            ? { unsubscribe: unsubscribeHandler }
            : unsubscribeHandler;
    }
    function observable() {
        var _a;
        return _a = {
                subscribe: function (observer) {
                    if (typeof observer !== 'object' || observer === null) {
                        throw new TypeError('Expected the observer to be an object.');
                    }
                    return subscribe(observer);
                }
            },
            _a[symbol_observable__WEBPACK_IMPORTED_MODULE_1__.default] = function () {
                return this;
            },
            _a;
    }
    router.subscribe = subscribe;
    //@ts-ignore
    router[symbol_observable__WEBPACK_IMPORTED_MODULE_1__.default] = observable;
    //@ts-ignore
    router['@@observable'] = observable;
    return router;
}

function resolve(functions, _a, callback) {
    var isCancelled = _a.isCancelled, toState = _a.toState, fromState = _a.fromState, _b = _a.errorKey, errorKey = _b === void 0 ? undefined : _b;
    var remainingFunctions = Array.isArray(functions)
        ? functions
        : Object.keys(functions);
    var isState = function (obj) {
        return typeof obj === 'object' &&
            obj.name !== undefined &&
            obj.params !== undefined &&
            obj.path !== undefined;
    };
    var hasStateChanged = function (toState, fromState) {
        return fromState.name !== toState.name ||
            fromState.params !== toState.params ||
            fromState.path !== toState.path;
    };
    var mergeStates = function (toState, fromState) { return (__assign(__assign(__assign({}, fromState), toState), { meta: __assign(__assign({}, fromState.meta), toState.meta) })); };
    var processFn = function (stepFn, errBase, state, _done) {
        var done = function (err, newState) {
            if (err) {
                _done(err);
            }
            else if (newState && newState !== state && isState(newState)) {
                if (hasStateChanged(newState, state)) {
                    console.error('[router5][transition] Warning: state values (name, params, path) were changed during transition process.');
                }
                _done(null, mergeStates(newState, state));
            }
            else {
                _done(null, state);
            }
        };
        var res = stepFn.call(null, state, fromState, done);
        if (isCancelled()) {
            done(null);
        }
        else if (typeof res === 'boolean') {
            done(res ? null : errBase);
        }
        else if (isState(res)) {
            done(null, res);
        }
        else if (res && typeof res.then === 'function') {
            res.then(function (resVal) {
                if (resVal instanceof Error)
                    done({ error: resVal }, null);
                else
                    done(null, resVal);
            }, function (err) {
                if (err instanceof Error) {
                    console.error(err.stack || err);
                    done(__assign(__assign({}, errBase), { promiseError: err }), null);
                }
                else {
                    done(typeof err === 'object'
                        ? __assign(__assign({}, errBase), err) : errBase, null);
                }
            });
        }
        // else: wait for done to be called
    };
    var next = function (err, state) {
        var _a;
        if (isCancelled()) {
            callback();
        }
        else if (err) {
            callback(err);
        }
        else {
            if (!remainingFunctions.length) {
                callback(null, state);
            }
            else {
                var isMapped = typeof remainingFunctions[0] === 'string';
                var errBase = errorKey && isMapped
                    ? (_a = {}, _a[errorKey] = remainingFunctions[0], _a) : {};
                var stepFn = isMapped
                    ? functions[remainingFunctions[0]]
                    : remainingFunctions[0];
                remainingFunctions = remainingFunctions.slice(1);
                processFn(stepFn, errBase, state, next);
            }
        }
    };
    next(null, toState);
}

function transition(router, toState, fromState, opts, callback) {
    var cancelled = false;
    var completed = false;
    var options = router.getOptions();
    var _a = router.getLifecycleFunctions(), canDeactivateFunctions = _a[0], canActivateFunctions = _a[1];
    var middlewareFunctions = router.getMiddlewareFunctions();
    var isCancelled = function () { return cancelled; };
    var cancel = function () {
        if (!cancelled && !completed) {
            cancelled = true;
            callback({ code: errorCodes.TRANSITION_CANCELLED }, null);
        }
    };
    var done = function (err, state) {
        completed = true;
        if (isCancelled()) {
            return;
        }
        if (!err && options.autoCleanUp) {
            var activeSegments_1 = (0,router5_transition_path__WEBPACK_IMPORTED_MODULE_2__.nameToIDs)(toState.name);
            Object.keys(canDeactivateFunctions).forEach(function (name) {
                if (activeSegments_1.indexOf(name) === -1)
                    router.clearCanDeactivate(name);
            });
        }
        callback(err, state || toState);
    };
    var makeError = function (base, err) { return (__assign(__assign({}, base), (err instanceof Object ? err : { error: err }))); };
    var isUnknownRoute = toState.name === constants.UNKNOWN_ROUTE;
    var asyncBase = { isCancelled: isCancelled, toState: toState, fromState: fromState };
    var _b = (0,router5_transition_path__WEBPACK_IMPORTED_MODULE_2__.default)(toState, fromState), toDeactivate = _b.toDeactivate, toActivate = _b.toActivate;
    var canDeactivate = !fromState || opts.forceDeactivate
        ? []
        : function (toState, fromState, cb) {
            var canDeactivateFunctionMap = toDeactivate
                .filter(function (name) { return canDeactivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign(__assign({}, fnMap), (_a = {}, _a[name] = canDeactivateFunctions[name], _a)));
            }, {});
            resolve(canDeactivateFunctionMap, __assign(__assign({}, asyncBase), { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_DEACTIVATE }, err)
                    : null);
            });
        };
    var canActivate = isUnknownRoute
        ? []
        : function (toState, fromState, cb) {
            var canActivateFunctionMap = toActivate
                .filter(function (name) { return canActivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign(__assign({}, fnMap), (_a = {}, _a[name] = canActivateFunctions[name], _a)));
            }, {});
            resolve(canActivateFunctionMap, __assign(__assign({}, asyncBase), { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_ACTIVATE }, err)
                    : null);
            });
        };
    var middleware = !middlewareFunctions.length
        ? []
        : function (toState, fromState, cb) {
            return resolve(middlewareFunctions, __assign({}, asyncBase), function (err, state) {
                return cb(err
                    ? makeError({ code: errorCodes.TRANSITION_ERR }, err)
                    : null, state || toState);
            });
        };
    var pipeline = []
        .concat(canDeactivate)
        .concat(canActivate)
        .concat(middleware);
    resolve(pipeline, asyncBase, done);
    return cancel;
}

var noop = function () { };
function withNavigation(router) {
    var cancelCurrentTransition;
    router.navigate = navigate;
    router.navigate = navigate;
    router.navigateToDefault = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var opts = typeof args[0] === 'object' ? args[0] : {};
        var done = args.length === 2
            ? args[1]
            : typeof args[0] === 'function'
                ? args[0]
                : noop;
        var options = router.getOptions();
        if (options.defaultRoute) {
            return navigate(options.defaultRoute, options.defaultParams, opts, done);
        }
        return function () { };
    };
    router.cancel = function () {
        if (cancelCurrentTransition) {
            cancelCurrentTransition('navigate');
            cancelCurrentTransition = null;
        }
        return router;
    };
    function navigate() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var name = args[0];
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop;
        var params = typeof args[1] === 'object' ? args[1] : {};
        var opts = typeof args[2] === 'object' ? args[2] : {};
        if (!router.isStarted()) {
            done({ code: errorCodes.ROUTER_NOT_STARTED });
            return;
        }
        var route = router.buildState(name, params);
        if (!route) {
            var err = { code: errorCodes.ROUTE_NOT_FOUND };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, null, router.getState(), err);
            return;
        }
        var toState = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta, options: opts });
        var sameStates = router.getState()
            ? router.areStatesEqual(router.getState(), toState, false)
            : false;
        // Do not proceed further if states are the same and no reload
        // (no deactivation and no callbacks)
        if (sameStates && !opts.reload && !opts.force) {
            var err = { code: errorCodes.SAME_STATES };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, toState, router.getState(), err);
            return;
        }
        var fromState = router.getState();
        if (opts.skipTransition) {
            done(null, toState);
            return noop;
        }
        // Transition
        return router.transitionToState(toState, fromState, opts, function (err, state) {
            if (err) {
                if (err.redirect) {
                    var _a = err.redirect, name_1 = _a.name, params_1 = _a.params;
                    navigate(name_1, params_1, __assign(__assign({}, opts), { force: true, redirected: true }), done);
                }
                else {
                    done(err);
                }
            }
            else {
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, fromState, opts);
                done(null, state);
            }
        });
    }
    router.transitionToState = function (toState, fromState, options, done) {
        if (options === void 0) { options = {}; }
        if (done === void 0) { done = noop; }
        router.cancel();
        router.invokeEventListeners(constants.TRANSITION_START, toState, fromState);
        cancelCurrentTransition = transition(router, toState, fromState, options, function (err, state) {
            cancelCurrentTransition = null;
            state = state || toState;
            if (err) {
                if (err.code === errorCodes.TRANSITION_CANCELLED) {
                    router.invokeEventListeners(constants.TRANSITION_CANCEL, toState, fromState);
                }
                else {
                    router.invokeEventListeners(constants.TRANSITION_ERROR, toState, fromState, err);
                }
                done(err);
            }
            else {
                router.setState(state);
                done(null, state);
            }
        });
        return cancelCurrentTransition;
    };
    return router;
}

var noop$1 = function () { };
function withRouterLifecycle(router) {
    var started = false;
    router.isStarted = function () { return started; };
    //@ts-ignore
    router.start = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var options = router.getOptions();
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop$1;
        var startPathOrState = typeof args[0] !== 'function' ? args[0] : undefined;
        if (started) {
            done({ code: errorCodes.ROUTER_ALREADY_STARTED });
            return router;
        }
        var startPath, startState;
        started = true;
        router.invokeEventListeners(constants.ROUTER_START);
        // callback
        var cb = function (err, state, invokeErrCb) {
            if (invokeErrCb === void 0) { invokeErrCb = true; }
            if (!err)
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, null, { replace: true });
            if (err && invokeErrCb)
                router.invokeEventListeners(constants.TRANSITION_ERROR, state, null, err);
            done(err, state);
        };
        if (startPathOrState === undefined && !options.defaultRoute) {
            return cb({ code: errorCodes.NO_START_PATH_OR_STATE });
        }
        if (typeof startPathOrState === 'string') {
            startPath = startPathOrState;
        }
        else if (typeof startPathOrState === 'object') {
            startState = startPathOrState;
        }
        if (!startState) {
            // If no supplied start state, get start state
            startState =
                startPath === undefined ? null : router.matchPath(startPath);
            // Navigate to default function
            var navigateToDefault_1 = function () {
                return router.navigateToDefault({ replace: true }, done);
            };
            var redirect_1 = function (route) {
                return router.navigate(route.name, route.params, { replace: true, reload: true, redirected: true }, done);
            };
            var transitionToState = function (state) {
                router.transitionToState(state, router.getState(), {}, function (err, state) {
                    if (!err)
                        cb(null, state);
                    else if (err.redirect)
                        redirect_1(err.redirect);
                    else if (options.defaultRoute)
                        navigateToDefault_1();
                    else
                        cb(err, null, false);
                });
            };
            // If matched start path
            if (startState) {
                transitionToState(startState);
            }
            else if (options.defaultRoute) {
                // If default, navigate to default
                navigateToDefault_1();
            }
            else if (options.allowNotFound) {
                transitionToState(router.makeNotFoundState(startPath, { replace: true }));
            }
            else {
                // No start match, no default => do nothing
                cb({ code: errorCodes.ROUTE_NOT_FOUND, path: startPath }, null);
            }
        }
        else {
            // Initialise router with provided start state
            router.setState(startState);
            cb(null, startState);
        }
        return router;
    };
    router.stop = function () {
        if (started) {
            router.setState(null);
            started = false;
            router.invokeEventListeners(constants.ROUTER_STOP);
        }
        return router;
    };
    return router;
}

var toFunction = function (val) { return (typeof val === 'function' ? val : function () { return function () { return val; }; }); };
function withRouteLifecycle(router) {
    var canDeactivateFactories = {};
    var canActivateFactories = {};
    var canDeactivateFunctions = {};
    var canActivateFunctions = {};
    router.getLifecycleFactories = function () {
        return [canDeactivateFactories, canActivateFactories];
    };
    router.getLifecycleFunctions = function () {
        return [canDeactivateFunctions, canActivateFunctions];
    };
    router.canDeactivate = function (name, canDeactivateHandler) {
        var factory = toFunction(canDeactivateHandler);
        canDeactivateFactories[name] = factory;
        canDeactivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    router.clearCanDeactivate = function (name) {
        canDeactivateFactories[name] = undefined;
        canDeactivateFunctions[name] = undefined;
        return router;
    };
    router.canActivate = function (name, canActivateHandler) {
        var factory = toFunction(canActivateHandler);
        canActivateFactories[name] = factory;
        canActivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    return router;
}

var pipe = function () {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return function (arg) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, arg);
    };
};
var createRouter = function (routes, options, dependencies) {
    if (routes === void 0) { routes = []; }
    if (options === void 0) { options = {}; }
    if (dependencies === void 0) { dependencies = {}; }
    var config = {
        decoders: {},
        encoders: {},
        defaultParams: {},
        forwardMap: {}
    };
    return pipe(withOptions(options), withDependencies(dependencies), withObservability, withState, withRouterLifecycle, withRouteLifecycle, withNavigation, withPlugins, withMiddleware, withRoutes(routes))({ config: config });
};

function cloneRouter(router, dependencies) {
    var clonedRouter = createRouter(router.rootNode, router.getOptions(), dependencies);
    clonedRouter.useMiddleware.apply(clonedRouter, router.getMiddlewareFactories());
    clonedRouter.usePlugin.apply(clonedRouter, router.getPlugins());
    clonedRouter.config = router.config;
    var _a = router.getLifecycleFactories(), canDeactivateFactories = _a[0], canActivateFactories = _a[1];
    Object.keys(canDeactivateFactories).forEach(function (name) {
        return clonedRouter.canDeactivate(name, canDeactivateFactories[name]);
    });
    Object.keys(canActivateFactories).forEach(function (name) {
        return clonedRouter.canActivate(name, canActivateFactories[name]);
    });
    return clonedRouter;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createRouter);



/***/ }),

/***/ "./node_modules/search-params/dist/search-params.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/search-params/dist/search-params.esm.js ***!
  \**************************************************************/
/*! namespace exports */
/*! export build [provided] [no usage info] [missing usage info prevents renaming] */
/*! export keep [provided] [no usage info] [missing usage info prevents renaming] */
/*! export omit [provided] [no usage info] [missing usage info prevents renaming] */
/*! export parse [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "build": () => /* binding */ build,
/* harmony export */   "keep": () => /* binding */ keep,
/* harmony export */   "omit": () => /* binding */ omit,
/* harmony export */   "parse": () => /* binding */ parse
/* harmony export */ });
var makeOptions = function makeOptions(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return {
    arrayFormat: opts.arrayFormat || 'none',
    booleanFormat: opts.booleanFormat || 'none',
    nullFormat: opts.nullFormat || 'default'
  };
};

var encodeValue = function encodeValue(value) {
  return encodeURIComponent(value);
};

var decodeValue = function decodeValue(value) {
  return decodeURIComponent(value);
};

var encodeBoolean = function encodeBoolean(name, value, opts) {
  if (opts.booleanFormat === 'empty-true' && value) {
    return name;
  }

  var encodedValue;

  if (opts.booleanFormat === 'unicode') {
    encodedValue = value ? '✓' : '✗';
  } else {
    encodedValue = value.toString();
  }

  return name + "=" + encodedValue;
};

var encodeNull = function encodeNull(name, opts) {
  if (opts.nullFormat === 'hidden') {
    return '';
  }

  if (opts.nullFormat === 'string') {
    return name + "=null";
  }

  return name;
};

var getNameEncoder = function getNameEncoder(opts) {
  if (opts.arrayFormat === 'index') {
    return function (name, index) {
      return name + "[" + index + "]";
    };
  }

  if (opts.arrayFormat === 'brackets') {
    return function (name) {
      return name + "[]";
    };
  }

  return function (name) {
    return name;
  };
};

var encodeArray = function encodeArray(name, arr, opts) {
  var encodeName = getNameEncoder(opts);
  return arr.map(function (val, index) {
    return encodeName(name, index) + "=" + encodeValue(val);
  }).join('&');
};
var encode = function encode(name, value, opts) {
  if (value === null) {
    return encodeNull(name, opts);
  }

  if (typeof value === 'boolean') {
    return encodeBoolean(name, value, opts);
  }

  if (Array.isArray(value)) {
    return encodeArray(name, value, opts);
  }

  return name + "=" + encodeValue(value);
};
var decode = function decode(value, opts) {
  if (value === undefined) {
    return opts.booleanFormat === 'empty-true' ? true : null;
  }

  if (opts.booleanFormat === 'string') {
    if (value === 'true') {
      return true;
    }

    if (value === 'false') {
      return false;
    }
  }

  if (opts.booleanFormat === 'unicode') {
    if (decodeValue(value) === '✓') {
      return true;
    }

    if (decodeValue(value) === '✗') {
      return false;
    }
  }

  if (opts.nullFormat === 'string') {
    if (value === 'null') {
      return null;
    }
  }

  return decodeValue(value);
};

var getSearch = function getSearch(path) {
  var pos = path.indexOf('?');

  if (pos === -1) {
    return path;
  }

  return path.slice(pos + 1);
};
var isSerialisable = function isSerialisable(val) {
  return val !== undefined;
};
var parseName = function parseName(name) {
  var bracketPosition = name.indexOf('[');
  var hasBrackets = bracketPosition !== -1;
  return {
    hasBrackets: hasBrackets,
    name: hasBrackets ? name.slice(0, bracketPosition) : name
  };
};

/**
 * Parse a querystring and return an object of parameters
 */

var parse = function parse(path, opts) {
  var options = makeOptions(opts);
  return getSearch(path).split('&').reduce(function (params, param) {
    var _a = param.split('='),
        rawName = _a[0],
        value = _a[1];

    var _b = parseName(rawName),
        hasBrackets = _b.hasBrackets,
        name = _b.name;

    var currentValue = params[name];
    var decodedValue = decode(value, options);

    if (currentValue === undefined) {
      params[name] = hasBrackets ? [decodedValue] : decodedValue;
    } else {
      params[name] = (Array.isArray(currentValue) ? currentValue : [currentValue]).concat(decodedValue);
    }

    return params;
  }, {});
};
/**
 * Build a querystring from an object of parameters
 */

var build = function build(params, opts) {
  var options = makeOptions(opts);
  return Object.keys(params).filter(function (paramName) {
    return isSerialisable(params[paramName]);
  }).map(function (paramName) {
    return encode(paramName, params[paramName], options);
  }).filter(Boolean).join('&');
};
/**
 * Remove a list of parameters from a querystring
 */

var omit = function omit(path, paramsToOmit, opts) {
  var options = makeOptions(opts);
  var searchPart = getSearch(path);

  if (searchPart === '') {
    return {
      querystring: '',
      removedParams: {}
    };
  }

  var _a = path.split('&').reduce(function (_a, chunk) {
    var left = _a[0],
        right = _a[1];
    var rawName = chunk.split('=')[0];
    var name = parseName(rawName).name;
    return paramsToOmit.indexOf(name) === -1 ? [left.concat(chunk), right] : [left, right.concat(chunk)];
  }, [[], []]),
      kept = _a[0],
      removed = _a[1];

  return {
    querystring: kept.join('&'),
    removedParams: parse(removed.join('&'), options)
  };
};
/**
 * Remove a list of parameters from a querystring
 */

var keep = function keep(path, paramsToKeep, opts) {
  var options = makeOptions(opts);
  var searchPart = getSearch(path);

  if (searchPart === '') {
    return {
      keptParams: {},
      querystring: ''
    };
  }

  var kept = path.split('&').reduce(function (acc, chunk) {
    var rawName = chunk.split('=')[0];
    var name = parseName(rawName).name;

    if (paramsToKeep.includes(name)) {
      acc.push(chunk);
    }

    return acc;
  }, []);
  return {
    keptParams: parse(kept.join('&'), options),
    querystring: kept.join('&')
  };
};


//# sourceMappingURL=search-params.esm.js.map


/***/ }),

/***/ "./node_modules/symbol-observable/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, module.loaded, module.id, module, __webpack_require__.hmd, __webpack_exports__, __webpack_require__.r, __webpack_require__.g, __webpack_require__.d, __webpack_require__.* */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "./node_modules/symbol-observable/es/ponyfill.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* global window */
;

var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  root = __webpack_require__.g;
} else if (true) {
  root = module;
} else {}

var result = (0,_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.default)(root);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (result);


/***/ }),

/***/ "./node_modules/symbol-observable/es/ponyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ symbolObservablePonyfill
/* harmony export */ });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! namespace exports */
/*! export __assign [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __asyncDelegator [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __asyncGenerator [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __asyncValues [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __await [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __awaiter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __classPrivateFieldGet [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __classPrivateFieldSet [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __createBinding [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __decorate [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __exportStar [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __extends [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __generator [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __importDefault [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __importStar [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __makeTemplateObject [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __metadata [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __param [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __read [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __rest [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __spread [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __spreadArrays [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __values [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": () => /* binding */ __extends,
/* harmony export */   "__assign": () => /* binding */ __assign,
/* harmony export */   "__rest": () => /* binding */ __rest,
/* harmony export */   "__decorate": () => /* binding */ __decorate,
/* harmony export */   "__param": () => /* binding */ __param,
/* harmony export */   "__metadata": () => /* binding */ __metadata,
/* harmony export */   "__awaiter": () => /* binding */ __awaiter,
/* harmony export */   "__generator": () => /* binding */ __generator,
/* harmony export */   "__createBinding": () => /* binding */ __createBinding,
/* harmony export */   "__exportStar": () => /* binding */ __exportStar,
/* harmony export */   "__values": () => /* binding */ __values,
/* harmony export */   "__read": () => /* binding */ __read,
/* harmony export */   "__spread": () => /* binding */ __spread,
/* harmony export */   "__spreadArrays": () => /* binding */ __spreadArrays,
/* harmony export */   "__await": () => /* binding */ __await,
/* harmony export */   "__asyncGenerator": () => /* binding */ __asyncGenerator,
/* harmony export */   "__asyncDelegator": () => /* binding */ __asyncDelegator,
/* harmony export */   "__asyncValues": () => /* binding */ __asyncValues,
/* harmony export */   "__makeTemplateObject": () => /* binding */ __makeTemplateObject,
/* harmony export */   "__importStar": () => /* binding */ __importStar,
/* harmony export */   "__importDefault": () => /* binding */ __importDefault,
/* harmony export */   "__classPrivateFieldGet": () => /* binding */ __classPrivateFieldGet,
/* harmony export */   "__classPrivateFieldSet": () => /* binding */ __classPrivateFieldSet
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yc2Nsb25lLy4vbm9kZV9tb2R1bGVzL3BhdGgtcGFyc2VyL2Rpc3QvcGF0aC1wYXJzZXIuZXNtLmpzIiwid2VicGFjazovL3JzY2xvbmUvLi9ub2RlX21vZHVsZXMvcm91dGUtbm9kZS9kaXN0L3JvdXRlLW5vZGUuZXNtLmpzIiwid2VicGFjazovL3JzY2xvbmUvLi9ub2RlX21vZHVsZXMvcm91dGVyNS1wbHVnaW4tYnJvd3Nlci9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3JzY2xvbmUvLi9ub2RlX21vZHVsZXMvcm91dGVyNS10cmFuc2l0aW9uLXBhdGgvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9yc2Nsb25lLy4vbm9kZV9tb2R1bGVzL3JvdXRlcjUvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9yc2Nsb25lLy4vbm9kZV9tb2R1bGVzL3NlYXJjaC1wYXJhbXMvZGlzdC9zZWFyY2gtcGFyYW1zLmVzbS5qcyIsIndlYnBhY2s6Ly9yc2Nsb25lLy4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL2luZGV4LmpzIiwid2VicGFjazovL3JzY2xvbmUvLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vcnNjbG9uZS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLENBQWlDO0FBQ1k7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUM7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxjQUFjLDJCQUEyQixFQUFFO0FBQzNDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0RBQXNELEVBQUU7QUFDeEQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLCtDQUFRLENBQUMsK0NBQVEsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLGFBQWE7O0FBRWxCO0FBQ0Esc0RBQXNEOztBQUV0RCx5REFBeUQ7O0FBRXpELDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLCtDQUFRLENBQUMsK0NBQVE7QUFDbkM7QUFDQTtBQUNBLEtBQUssdUJBQXVCOzs7QUFHNUIsNEVBQTRFOztBQUU1RSwwSUFBMEk7O0FBRTFJO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCxzQkFBc0Isb0RBQUs7QUFDM0I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsK0NBQVEsQ0FBQywrQ0FBUTtBQUNuQztBQUNBO0FBQ0EsS0FBSyx1QkFBdUI7QUFDNUI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isb0RBQUs7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwrQ0FBUSxDQUFDLCtDQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSyxJQUFJLEVBQUU7O0FBRVg7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLDJGQUEyRix1Q0FBdUM7QUFDbEksS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1QscUJBQXFCLG9EQUFLO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUE7QUFDQSxDQUFDOztBQUVlO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFaQSxDQUFpQztBQUNFO0FBQ2dCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUkseUNBQXlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0RBQW9EOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLHdCQUF3QjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQLG1CQUFtQixvREFBSztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILGlCQUFpQixHQUFHO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1EQUFJO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxvREFBSztBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKLG1DQUFtQyxxQkFBcUI7QUFDeEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRGQUE0Rjs7QUFFNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2Q0FBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDZDQUFJO0FBQ2pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxXQUFXLCtDQUFRLENBQUMsK0NBQVEsR0FBRztBQUMvQjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRW9CO0FBQ3JCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsb0JBLENBQWdEOztBQUVoRDtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxn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Ozs7OztBQ2p6QjVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUN2QztBQUNBO0FBQ0E7O0FBRU87QUFDUCw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFTztBQUNQLGlEQUFpRCxRQUFRO0FBQ3pELHdDQUF3QyxRQUFRO0FBQ2hELHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHNGQUFzRixhQUFhLEVBQUU7QUFDdEgsc0JBQXNCLGdDQUFnQyxxQ0FBcUMsMENBQTBDLEVBQUUsRUFBRSxHQUFHO0FBQzVJLDJCQUEyQixNQUFNLGVBQWUsRUFBRSxZQUFZLG9CQUFvQixFQUFFO0FBQ3BGLHNCQUFzQixvR0FBb0c7QUFDMUgsNkJBQTZCLHVCQUF1QjtBQUNwRCw0QkFBNEIsd0JBQXdCO0FBQ3BELDJCQUEyQix5REFBeUQ7QUFDcEY7O0FBRU87QUFDUDtBQUNBLGlCQUFpQiw0Q0FBNEMsU0FBUyxFQUFFLHFEQUFxRCxhQUFhLEVBQUU7QUFDNUkseUJBQXlCLDZCQUE2QixvQkFBb0IsZ0RBQWdELGdCQUFnQixFQUFFLEtBQUs7QUFDako7O0FBRU87QUFDUDtBQUNBO0FBQ0EsMkdBQTJHLHNGQUFzRixhQUFhLEVBQUU7QUFDaE4sc0JBQXNCLDhCQUE4QixnREFBZ0QsdURBQXVELEVBQUUsRUFBRSxHQUFHO0FBQ2xLLDRDQUE0QyxzQ0FBc0MsVUFBVSxvQkFBb0IsRUFBRSxFQUFFLFVBQVU7QUFDOUg7O0FBRU87QUFDUCxnQ0FBZ0MsdUNBQXVDLGFBQWEsRUFBRSxFQUFFLE9BQU8sa0JBQWtCO0FBQ2pIO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCw0Q0FBNEM7QUFDNUM7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6InZlbmRvcnMtbm9kZV9tb2R1bGVzX3JvdXRlcjUtcGx1Z2luLWJyb3dzZXJfZGlzdF9pbmRleF9lc19qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgcGFyc2UsIGJ1aWxkIH0gZnJvbSAnc2VhcmNoLXBhcmFtcyc7XG5cbi8qKlxyXG4gKiBXZSBlbmNvZGUgdXNpbmcgZW5jb2RlVVJJQ29tcG9uZW50IGJ1dCB3ZSB3YW50IHRvXHJcbiAqIHByZXNlcnZlciBjZXJ0YWluIGNoYXJhY3RlcnMgd2hpY2ggYXJlIGNvbW1vbmx5IHVzZWRcclxuICogKHN1YiBkZWxpbWl0ZXJzIGFuZCAnOicpXHJcbiAqXHJcbiAqIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzOTg2LnR4dFxyXG4gKlxyXG4gKiByZXNlcnZlZCAgICA9IGdlbi1kZWxpbXMgLyBzdWItZGVsaW1zXHJcbiAqXHJcbiAqIGdlbi1kZWxpbXMgID0gXCI6XCIgLyBcIi9cIiAvIFwiP1wiIC8gXCIjXCIgLyBcIltcIiAvIFwiXVwiIC8gXCJAXCJcclxuICpcclxuICogc3ViLWRlbGltcyAgPSBcIiFcIiAvIFwiJFwiIC8gXCImXCIgLyBcIidcIiAvIFwiKFwiIC8gXCIpXCJcclxuICAgICAgICAgICAgICAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcclxuICovXG52YXIgZXhjbHVkZVN1YkRlbGltaXRlcnMgPSAvW14hJCcoKSorLDt8Ol0vZztcbnZhciBlbmNvZGVVUklDb21wb25lbnRFeGNsdWRpbmdTdWJEZWxpbXMgPSBmdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRFeGNsdWRpbmdTdWJEZWxpbXMoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudC5yZXBsYWNlKGV4Y2x1ZGVTdWJEZWxpbWl0ZXJzLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG59O1xudmFyIGVuY29kaW5nTWV0aG9kcyA9IHtcbiAgXCJkZWZhdWx0XCI6IGVuY29kZVVSSUNvbXBvbmVudEV4Y2x1ZGluZ1N1YkRlbGltcyxcbiAgdXJpOiBlbmNvZGVVUkksXG4gIHVyaUNvbXBvbmVudDogZW5jb2RlVVJJQ29tcG9uZW50LFxuICBub25lOiBmdW5jdGlvbiBub25lKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH0sXG4gIGxlZ2FjeTogZW5jb2RlVVJJXG59O1xudmFyIGRlY29kaW5nTWV0aG9kcyA9IHtcbiAgXCJkZWZhdWx0XCI6IGRlY29kZVVSSUNvbXBvbmVudCxcbiAgdXJpOiBkZWNvZGVVUkksXG4gIHVyaUNvbXBvbmVudDogZGVjb2RlVVJJQ29tcG9uZW50LFxuICBub25lOiBmdW5jdGlvbiBub25lKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH0sXG4gIGxlZ2FjeTogZGVjb2RlVVJJQ29tcG9uZW50XG59O1xudmFyIGVuY29kZVBhcmFtID0gZnVuY3Rpb24gZW5jb2RlUGFyYW0ocGFyYW0sIGVuY29kaW5nLCBpc1NwYXRQYXJhbSkge1xuICB2YXIgZW5jb2RlciA9IGVuY29kaW5nTWV0aG9kc1tlbmNvZGluZ10gfHwgZW5jb2RlVVJJQ29tcG9uZW50RXhjbHVkaW5nU3ViRGVsaW1zO1xuXG4gIGlmIChpc1NwYXRQYXJhbSkge1xuICAgIHJldHVybiBTdHJpbmcocGFyYW0pLnNwbGl0KCcvJykubWFwKGVuY29kZXIpLmpvaW4oJy8nKTtcbiAgfVxuXG4gIHJldHVybiBlbmNvZGVyKFN0cmluZyhwYXJhbSkpO1xufTtcbnZhciBkZWNvZGVQYXJhbSA9IGZ1bmN0aW9uIGRlY29kZVBhcmFtKHBhcmFtLCBlbmNvZGluZykge1xuICByZXR1cm4gKGRlY29kaW5nTWV0aG9kc1tlbmNvZGluZ10gfHwgZGVjb2RlVVJJQ29tcG9uZW50KShwYXJhbSk7XG59O1xuXG52YXIgZGVmYXVsdE9yQ29uc3RyYWluZWQgPSBmdW5jdGlvbiBkZWZhdWx0T3JDb25zdHJhaW5lZChtYXRjaCkge1xuICByZXR1cm4gJygnICsgKG1hdGNoID8gbWF0Y2gucmVwbGFjZSgvKF48fD4kKS9nLCAnJykgOiBcIlthLXpBLVowLTktXy5+JSc6fD0rXFxcXCpAJF0rXCIpICsgJyknO1xufTtcbnZhciBydWxlcyA9IFt7XG4gIG5hbWU6ICd1cmwtcGFyYW1ldGVyJyxcbiAgcGF0dGVybjogL146KFthLXpBLVowLTktX10qW2EtekEtWjAtOV17MX0pKDwoLis/KT4pPy8sXG4gIHJlZ2V4OiBmdW5jdGlvbiByZWdleChtYXRjaCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGRlZmF1bHRPckNvbnN0cmFpbmVkKG1hdGNoWzJdKSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3VybC1wYXJhbWV0ZXItc3BsYXQnLFxuICBwYXR0ZXJuOiAvXlxcKihbYS16QS1aMC05LV9dKlthLXpBLVowLTldezF9KS8sXG4gIHJlZ2V4OiAvKFteP10qKS9cbn0sIHtcbiAgbmFtZTogJ3VybC1wYXJhbWV0ZXItbWF0cml4JyxcbiAgcGF0dGVybjogL147KFthLXpBLVowLTktX10qW2EtekEtWjAtOV17MX0pKDwoLis/KT4pPy8sXG4gIHJlZ2V4OiBmdW5jdGlvbiByZWdleChtYXRjaCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCc7JyArIG1hdGNoWzFdICsgJz0nICsgZGVmYXVsdE9yQ29uc3RyYWluZWQobWF0Y2hbMl0pKTtcbiAgfVxufSwge1xuICBuYW1lOiAncXVlcnktcGFyYW1ldGVyJyxcbiAgcGF0dGVybjogL14oPzpcXD98JikoPzo6KT8oW2EtekEtWjAtOS1fXSpbYS16QS1aMC05XXsxfSkvXG59LCB7XG4gIG5hbWU6ICdkZWxpbWl0ZXInLFxuICBwYXR0ZXJuOiAvXihcXC98XFw/KS8sXG4gIHJlZ2V4OiBmdW5jdGlvbiByZWdleChtYXRjaCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCdcXFxcJyArIG1hdGNoWzBdKTtcbiAgfVxufSwge1xuICBuYW1lOiAnc3ViLWRlbGltaXRlcicsXG4gIHBhdHRlcm46IC9eKCF8JnwtfF98XFwufDspLyxcbiAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KG1hdGNoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAobWF0Y2hbMF0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdmcmFnbWVudCcsXG4gIHBhdHRlcm46IC9eKFswLTlhLXpBLVpdKykvLFxuICByZWdleDogZnVuY3Rpb24gcmVnZXgobWF0Y2gpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChtYXRjaFswXSk7XG4gIH1cbn1dO1xuXG52YXIgdG9rZW5pc2UgPSBmdW5jdGlvbiB0b2tlbmlzZShzdHIsIHRva2Vucykge1xuICBpZiAodG9rZW5zID09PSB2b2lkIDApIHtcbiAgICB0b2tlbnMgPSBbXTtcbiAgfSAvLyBMb29rIGZvciBhIG1hdGNoaW5nIHJ1bGVcblxuXG4gIHZhciBtYXRjaGVkID0gcnVsZXMuc29tZShmdW5jdGlvbiAocnVsZSkge1xuICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChydWxlLnBhdHRlcm4pO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6IHJ1bGUubmFtZSxcbiAgICAgIG1hdGNoOiBtYXRjaFswXSxcbiAgICAgIHZhbDogbWF0Y2guc2xpY2UoMSwgMiksXG4gICAgICBvdGhlclZhbDogbWF0Y2guc2xpY2UoMiksXG4gICAgICByZWdleDogcnVsZS5yZWdleCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gcnVsZS5yZWdleChtYXRjaCkgOiBydWxlLnJlZ2V4XG4gICAgfSk7XG5cbiAgICBpZiAobWF0Y2hbMF0ubGVuZ3RoIDwgc3RyLmxlbmd0aCkge1xuICAgICAgdG9rZW5zID0gdG9rZW5pc2Uoc3RyLnN1YnN0cihtYXRjaFswXS5sZW5ndGgpLCB0b2tlbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTsgLy8gSWYgbm8gcnVsZXMgbWF0Y2hlZCwgdGhyb3cgYW4gZXJyb3IgKHBvc3NpYmxlIG1hbGZvcm1lZCBwYXRoKVxuXG4gIGlmICghbWF0Y2hlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBwYXRoICdcIiArIHN0ciArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59O1xuXG52YXIgZXhpc3RzID0gZnVuY3Rpb24gZXhpc3RzKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsO1xufTtcblxudmFyIG9wdFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBvcHRUcmFpbGluZ1NsYXNoKHNvdXJjZSwgc3RyaWN0VHJhaWxpbmdTbGFzaCkge1xuICBpZiAoc3RyaWN0VHJhaWxpbmdTbGFzaCkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBpZiAoc291cmNlID09PSAnXFxcXC8nKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2UucmVwbGFjZSgvXFxcXFxcLyQvLCAnJykgKyAnKD86XFxcXC8pPyc7XG59O1xuXG52YXIgdXBUb0RlbGltaXRlciA9IGZ1bmN0aW9uIHVwVG9EZWxpbWl0ZXIoc291cmNlLCBkZWxpbWl0ZXIpIHtcbiAgaWYgKCFkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgcmV0dXJuIC8oXFwvKSQvLnRlc3Qoc291cmNlKSA/IHNvdXJjZSA6IHNvdXJjZSArICcoXFxcXC98XFxcXD98XFxcXC58O3wkKSc7XG59O1xuXG52YXIgYXBwZW5kUXVlcnlQYXJhbSA9IGZ1bmN0aW9uIGFwcGVuZFF1ZXJ5UGFyYW0ocGFyYW1zLCBwYXJhbSwgdmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgIHZhbCA9ICcnO1xuICB9XG5cbiAgdmFyIGV4aXN0aW5nVmFsID0gcGFyYW1zW3BhcmFtXTtcblxuICBpZiAoZXhpc3RpbmdWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtc1twYXJhbV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zW3BhcmFtXSA9IEFycmF5LmlzQXJyYXkoZXhpc3RpbmdWYWwpID8gZXhpc3RpbmdWYWwuY29uY2F0KHZhbCkgOiBbZXhpc3RpbmdWYWwsIHZhbF07XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICB1cmxQYXJhbXNFbmNvZGluZzogJ2RlZmF1bHQnXG59O1xuXG52YXIgUGF0aCA9XG4vKiNfX1BVUkVfXyovXG5cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGF0aChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcGF0aCBpbiBQYXRoIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB0aGlzLnRva2VucyA9IHRva2VuaXNlKHBhdGgpO1xuICAgIHRoaXMuaGFzVXJsUGFyYW1zID0gdGhpcy50b2tlbnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gL151cmwtcGFyYW1ldGVyLy50ZXN0KHQudHlwZSk7XG4gICAgfSkubGVuZ3RoID4gMDtcbiAgICB0aGlzLmhhc1NwYXRQYXJhbSA9IHRoaXMudG9rZW5zLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIC9zcGxhdCQvLnRlc3QodC50eXBlKTtcbiAgICB9KS5sZW5ndGggPiAwO1xuICAgIHRoaXMuaGFzTWF0cml4UGFyYW1zID0gdGhpcy50b2tlbnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gL21hdHJpeCQvLnRlc3QodC50eXBlKTtcbiAgICB9KS5sZW5ndGggPiAwO1xuICAgIHRoaXMuaGFzUXVlcnlQYXJhbXMgPSB0aGlzLnRva2Vucy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAvXnF1ZXJ5LXBhcmFtZXRlci8udGVzdCh0LnR5cGUpO1xuICAgIH0pLmxlbmd0aCA+IDA7IC8vIEV4dHJhY3QgbmFtZWQgcGFyYW1ldGVycyBmcm9tIHRva2Vuc1xuXG4gICAgdGhpcy5zcGF0UGFyYW1zID0gdGhpcy5nZXRQYXJhbXMoJ3VybC1wYXJhbWV0ZXItc3BsYXQnKTtcbiAgICB0aGlzLnVybFBhcmFtcyA9IHRoaXMuZ2V0UGFyYW1zKC9edXJsLXBhcmFtZXRlci8pOyAvLyBRdWVyeSBwYXJhbXNcblxuICAgIHRoaXMucXVlcnlQYXJhbXMgPSB0aGlzLmdldFBhcmFtcygncXVlcnktcGFyYW1ldGVyJyk7IC8vIEFsbCBwYXJhbXNcblxuICAgIHRoaXMucGFyYW1zID0gdGhpcy51cmxQYXJhbXMuY29uY2F0KHRoaXMucXVlcnlQYXJhbXMpOyAvLyBDaGVjayBpZiBoYXNRdWVyeVBhcmFtc1xuICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIHVybCBwYXJ0IG9ubHkgKGZ1bGwgYW5kIHBhcnRpYWwgbWF0Y2gpXG5cbiAgICB0aGlzLnNvdXJjZSA9IHRoaXMudG9rZW5zLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQucmVnZXggIT09IHVuZGVmaW5lZDtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LnJlZ2V4LnNvdXJjZTtcbiAgICB9KS5qb2luKCcnKTtcbiAgfVxuXG4gIFBhdGguY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXRoKHBhdGgsIG9wdGlvbnMpO1xuICB9O1xuXG4gIFBhdGgucHJvdG90eXBlLmlzUXVlcnlQYXJhbSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlQYXJhbXMuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gIH07XG5cbiAgUGF0aC5wcm90b3R5cGUuaXNTcGF0UGFyYW0gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNwYXRQYXJhbXMuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gIH07XG5cbiAgUGF0aC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIChwYXRoLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe1xuICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICBzdHJpY3RUcmFpbGluZ1NsYXNoOiBmYWxzZVxuICAgIH0sIHRoaXMub3B0aW9ucyksIG9wdHMpOyAvLyB0cmFpbGluZ1NsYXNoOiBmYWxzeSA9PiBub24gb3B0aW9uYWwsIHRydXRoeSA9PiBvcHRpb25hbFxuXG5cbiAgICB2YXIgc291cmNlID0gb3B0VHJhaWxpbmdTbGFzaCh0aGlzLnNvdXJjZSwgb3B0aW9ucy5zdHJpY3RUcmFpbGluZ1NsYXNoKTsgLy8gQ2hlY2sgaWYgZXhhY3QgbWF0Y2hcblxuICAgIHZhciBtYXRjaCA9IHRoaXMudXJsVGVzdChwYXRoLCBzb3VyY2UgKyAodGhpcy5oYXNRdWVyeVBhcmFtcyA/ICcoXFxcXD8uKiR8JCknIDogJyQnKSwgb3B0aW9ucy5jYXNlU2Vuc2l0aXZlLCBvcHRpb25zLnVybFBhcmFtc0VuY29kaW5nKTsgLy8gSWYgbm8gbWF0Y2gsIG9yIG5vIHF1ZXJ5IHBhcmFtcywgbm8gbmVlZCB0byBnbyBmdXJ0aGVyXG5cbiAgICBpZiAoIW1hdGNoIHx8ICF0aGlzLmhhc1F1ZXJ5UGFyYW1zKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSAvLyBFeHRyYWN0IHF1ZXJ5IHBhcmFtc1xuXG5cbiAgICB2YXIgcXVlcnlQYXJhbXMgPSBwYXJzZShwYXRoLCBvcHRpb25zLnF1ZXJ5UGFyYW1zKTtcbiAgICB2YXIgdW5leHBlY3RlZFF1ZXJ5UGFyYW1zID0gT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICFfdGhpcy5pc1F1ZXJ5UGFyYW0ocCk7XG4gICAgfSk7XG5cbiAgICBpZiAodW5leHBlY3RlZFF1ZXJ5UGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRXh0ZW5kIHVybCBtYXRjaFxuICAgICAgT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpLmZvckVhY2goIC8vIEB0cy1pZ25vcmVcbiAgICAgIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFtwXSA9IHF1ZXJ5UGFyYW1zW3BdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgUGF0aC5wcm90b3R5cGUucGFydGlhbFRlc3QgPSBmdW5jdGlvbiAocGF0aCwgb3B0cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgZGVsaW1pdGVkOiB0cnVlXG4gICAgfSwgdGhpcy5vcHRpb25zKSwgb3B0cyk7IC8vIENoZWNrIGlmIHBhcnRpYWwgbWF0Y2ggKHN0YXJ0IG9mIGdpdmVuIHBhdGggbWF0Y2hlcyByZWdleClcbiAgICAvLyB0cmFpbGluZ1NsYXNoOiBmYWxzeSA9PiBub24gb3B0aW9uYWwsIHRydXRoeSA9PiBvcHRpb25hbFxuXG5cbiAgICB2YXIgc291cmNlID0gdXBUb0RlbGltaXRlcih0aGlzLnNvdXJjZSwgb3B0aW9ucy5kZWxpbWl0ZWQpO1xuICAgIHZhciBtYXRjaCA9IHRoaXMudXJsVGVzdChwYXRoLCBzb3VyY2UsIG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSwgb3B0aW9ucy51cmxQYXJhbXNFbmNvZGluZyk7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhhc1F1ZXJ5UGFyYW1zKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgdmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2UocGF0aCwgb3B0aW9ucy5xdWVyeVBhcmFtcyk7XG4gICAgT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIF90aGlzLmlzUXVlcnlQYXJhbShwKTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gYXBwZW5kUXVlcnlQYXJhbShtYXRjaCwgcCwgcXVlcnlQYXJhbXNbcF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICBQYXRoLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgIGlnbm9yZUNvbnN0cmFpbnRzOiBmYWxzZSxcbiAgICAgIGlnbm9yZVNlYXJjaDogZmFsc2UsXG4gICAgICBxdWVyeVBhcmFtczoge31cbiAgICB9LCB0aGlzLm9wdGlvbnMpLCBvcHRzKTtcblxuICAgIHZhciBlbmNvZGVkVXJsUGFyYW1zID0gT2JqZWN0LmtleXMocGFyYW1zKS5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAhX3RoaXMuaXNRdWVyeVBhcmFtKHApO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgIGlmICghZXhpc3RzKHBhcmFtc1trZXldKSkge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsID0gcGFyYW1zW2tleV07XG5cbiAgICAgIHZhciBpc1NwYXRQYXJhbSA9IF90aGlzLmlzU3BhdFBhcmFtKGtleSk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgYWNjW2tleV0gPSB2YWw7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbC5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gZW5jb2RlUGFyYW0odiwgb3B0aW9ucy51cmxQYXJhbXNFbmNvZGluZywgaXNTcGF0UGFyYW0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjY1trZXldID0gZW5jb2RlUGFyYW0odmFsLCBvcHRpb25zLnVybFBhcmFtc0VuY29kaW5nLCBpc1NwYXRQYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pOyAvLyBDaGVjayBhbGwgcGFyYW1zIGFyZSBwcm92aWRlZCAobm90IHNlYXJjaCBwYXJhbWV0ZXJzIHdoaWNoIGFyZSBvcHRpb25hbClcblxuICAgIGlmICh0aGlzLnVybFBhcmFtcy5zb21lKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gIWV4aXN0cyhwYXJhbXNbcF0pO1xuICAgIH0pKSB7XG4gICAgICB2YXIgbWlzc2luZ1BhcmFtZXRlcnMgPSB0aGlzLnVybFBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuICFleGlzdHMocGFyYW1zW3BdKTtcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGJ1aWxkIHBhdGg6ICdcIiArIHRoaXMucGF0aCArIFwiJyByZXF1aXJlcyBtaXNzaW5nIHBhcmFtZXRlcnMgeyBcIiArIG1pc3NpbmdQYXJhbWV0ZXJzLmpvaW4oJywgJykgKyAnIH0nKTtcbiAgICB9IC8vIENoZWNrIGNvbnN0cmFpbnRzXG5cblxuICAgIGlmICghb3B0aW9ucy5pZ25vcmVDb25zdHJhaW50cykge1xuICAgICAgdmFyIGNvbnN0cmFpbnRzUGFzc2VkID0gdGhpcy50b2tlbnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAvXnVybC1wYXJhbWV0ZXIvLnRlc3QodC50eXBlKSAmJiAhLy1zcGxhdCQvLnRlc3QodC50eXBlKTtcbiAgICAgIH0pLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIGRlZmF1bHRPckNvbnN0cmFpbmVkKHQub3RoZXJWYWxbMF0pICsgJyQnKS50ZXN0KGVuY29kZWRVcmxQYXJhbXNbdC52YWxdKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWNvbnN0cmFpbnRzUGFzc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWUgcGFyYW1ldGVycyBvZiAnXCIgKyB0aGlzLnBhdGggKyBcIicgYXJlIG9mIGludmFsaWQgZm9ybWF0XCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiYXNlID0gdGhpcy50b2tlbnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gL15xdWVyeS1wYXJhbWV0ZXIvLnRlc3QodC50eXBlKSA9PT0gZmFsc2U7XG4gICAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodC50eXBlID09PSAndXJsLXBhcmFtZXRlci1tYXRyaXgnKSB7XG4gICAgICAgIHJldHVybiBcIjtcIiArIHQudmFsICsgXCI9XCIgKyBlbmNvZGVkVXJsUGFyYW1zW3QudmFsWzBdXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC9edXJsLXBhcmFtZXRlci8udGVzdCh0LnR5cGUpID8gZW5jb2RlZFVybFBhcmFtc1t0LnZhbFswXV0gOiB0Lm1hdGNoO1xuICAgIH0pLmpvaW4oJycpO1xuXG4gICAgaWYgKG9wdGlvbnMuaWdub3JlU2VhcmNoKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICB2YXIgc2VhcmNoUGFyYW1zID0gdGhpcy5xdWVyeVBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLmluZGV4T2YocCkgIT09IC0xO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoc3BhcmFtcywgcGFyYW1OYW1lKSB7XG4gICAgICBzcGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbXNbcGFyYW1OYW1lXTtcbiAgICAgIHJldHVybiBzcGFyYW1zO1xuICAgIH0sIHt9KTtcbiAgICB2YXIgc2VhcmNoUGFydCA9IGJ1aWxkKHNlYXJjaFBhcmFtcywgb3B0aW9ucy5xdWVyeVBhcmFtcyk7XG4gICAgcmV0dXJuIHNlYXJjaFBhcnQgPyBiYXNlICsgJz8nICsgc2VhcmNoUGFydCA6IGJhc2U7XG4gIH07XG5cbiAgUGF0aC5wcm90b3R5cGUuZ2V0UGFyYW1zID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgcHJlZGljYXRlID0gdHlwZSBpbnN0YW5jZW9mIFJlZ0V4cCA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdHlwZS50ZXN0KHQudHlwZSk7XG4gICAgfSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC50eXBlID09PSB0eXBlO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zLmZpbHRlcihwcmVkaWNhdGUpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQudmFsWzBdO1xuICAgIH0pO1xuICB9O1xuXG4gIFBhdGgucHJvdG90eXBlLnVybFRlc3QgPSBmdW5jdGlvbiAocGF0aCwgc291cmNlLCBjYXNlU2Vuc2l0aXZlLCB1cmxQYXJhbXNFbmNvZGluZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIHNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/ICcnIDogJ2knKTtcbiAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKHJlZ2V4KTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMudXJsUGFyYW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH0gLy8gUmVkdWNlIG5hbWVkIHBhcmFtcyB0byBrZXktdmFsdWUgcGFpcnNcblxuXG4gICAgcmV0dXJuIG1hdGNoLnNsaWNlKDEsIHRoaXMudXJsUGFyYW1zLmxlbmd0aCArIDEpLnJlZHVjZShmdW5jdGlvbiAocGFyYW1zLCBtLCBpKSB7XG4gICAgICBwYXJhbXNbX3RoaXMudXJsUGFyYW1zW2ldXSA9IGRlY29kZVBhcmFtKG0sIHVybFBhcmFtc0VuY29kaW5nKTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSwge30pO1xuICB9O1xuXG4gIHJldHVybiBQYXRoO1xufSgpO1xuXG5leHBvcnQgeyBQYXRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLXBhcnNlci5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICdwYXRoLXBhcnNlcic7XG5pbXBvcnQgeyBidWlsZCwgb21pdCwgcGFyc2UgfSBmcm9tICdzZWFyY2gtcGFyYW1zJztcblxudmFyIGdldE1ldGFGcm9tU2VnbWVudHMgPSBmdW5jdGlvbiBnZXRNZXRhRnJvbVNlZ21lbnRzKHNlZ21lbnRzKSB7XG4gIHZhciBhY2NOYW1lID0gJyc7XG4gIHJldHVybiBzZWdtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKG1ldGEsIHNlZ21lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG5cbiAgICB2YXIgdXJsUGFyYW1zID0gKF9iID0gKF9hID0gc2VnbWVudC5wYXJzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmxQYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHApIHtcbiAgICAgIHBhcmFtc1twXSA9ICd1cmwnO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LCB7fSksIF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KTtcbiAgICB2YXIgYWxsUGFyYW1zID0gKF9kID0gKF9jID0gc2VnbWVudC5wYXJzZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5xdWVyeVBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKHBhcmFtcywgcCkge1xuICAgICAgcGFyYW1zW3BdID0gJ3F1ZXJ5JztcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSwgdXJsUGFyYW1zKSwgX2QgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDoge30pO1xuXG4gICAgaWYgKHNlZ21lbnQubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhY2NOYW1lID0gYWNjTmFtZSA/IGFjY05hbWUgKyAnLicgKyBzZWdtZW50Lm5hbWUgOiBzZWdtZW50Lm5hbWU7XG4gICAgICBtZXRhW2FjY05hbWVdID0gYWxsUGFyYW1zO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhO1xuICB9LCB7fSk7XG59O1xudmFyIGJ1aWxkU3RhdGVGcm9tTWF0Y2ggPSBmdW5jdGlvbiBidWlsZFN0YXRlRnJvbU1hdGNoKG1hdGNoKSB7XG4gIGlmICghbWF0Y2ggfHwgIW1hdGNoLnNlZ21lbnRzIHx8ICFtYXRjaC5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBuYW1lID0gbWF0Y2guc2VnbWVudHMubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgcmV0dXJuIHNlZ21lbnQubmFtZTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH0pLmpvaW4oJy4nKTtcbiAgdmFyIHBhcmFtcyA9IG1hdGNoLnBhcmFtcztcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBhcmFtczogcGFyYW1zLFxuICAgIG1ldGE6IGdldE1ldGFGcm9tU2VnbWVudHMobWF0Y2guc2VnbWVudHMpXG4gIH07XG59O1xudmFyIGJ1aWxkUGF0aEZyb21TZWdtZW50cyA9IGZ1bmN0aW9uIGJ1aWxkUGF0aEZyb21TZWdtZW50cyhzZWdtZW50cywgcGFyYW1zLCBvcHRpb25zKSB7XG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfYSA9IG9wdGlvbnMucXVlcnlQYXJhbXNNb2RlLFxuICAgICAgcXVlcnlQYXJhbXNNb2RlID0gX2EgPT09IHZvaWQgMCA/ICdkZWZhdWx0JyA6IF9hLFxuICAgICAgX2IgPSBvcHRpb25zLnRyYWlsaW5nU2xhc2hNb2RlLFxuICAgICAgdHJhaWxpbmdTbGFzaE1vZGUgPSBfYiA9PT0gdm9pZCAwID8gJ2RlZmF1bHQnIDogX2I7XG4gIHZhciBzZWFyY2hQYXJhbXMgPSBbXTtcbiAgdmFyIG5vblNlYXJjaFBhcmFtcyA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gMCwgc2VnbWVudHNfMSA9IHNlZ21lbnRzOyBfaSA8IHNlZ21lbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c18xW19pXTtcbiAgICB2YXIgcGFyc2VyID0gc2VnbWVudC5wYXJzZXI7XG5cbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICBzZWFyY2hQYXJhbXMucHVzaC5hcHBseShzZWFyY2hQYXJhbXMsIHBhcnNlci5xdWVyeVBhcmFtcyk7XG4gICAgICBub25TZWFyY2hQYXJhbXMucHVzaC5hcHBseShub25TZWFyY2hQYXJhbXMsIHBhcnNlci51cmxQYXJhbXMpO1xuICAgICAgbm9uU2VhcmNoUGFyYW1zLnB1c2guYXBwbHkobm9uU2VhcmNoUGFyYW1zLCBwYXJzZXIuc3BhdFBhcmFtcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXJ5UGFyYW1zTW9kZSA9PT0gJ2xvb3NlJykge1xuICAgIHZhciBleHRyYVBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmFtcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHApIHtcbiAgICAgIHJldHVybiBzZWFyY2hQYXJhbXMuaW5kZXhPZihwKSA9PT0gLTEgJiYgbm9uU2VhcmNoUGFyYW1zLmluZGV4T2YocCkgPT09IC0xID8gYWNjLmNvbmNhdChwKSA6IGFjYztcbiAgICB9LCBbXSk7XG4gICAgc2VhcmNoUGFyYW1zLnB1c2guYXBwbHkoc2VhcmNoUGFyYW1zLCBleHRyYVBhcmFtcyk7XG4gIH1cblxuICB2YXIgc2VhcmNoUGFyYW1zT2JqZWN0ID0gc2VhcmNoUGFyYW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwYXJhbU5hbWUpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1zKS5pbmRleE9mKHBhcmFtTmFtZSkgIT09IC0xKSB7XG4gICAgICBhY2NbcGFyYW1OYW1lXSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIHNlYXJjaFBhcnQgPSBidWlsZChzZWFyY2hQYXJhbXNPYmplY3QsIG9wdGlvbnMucXVlcnlQYXJhbXMpO1xuICB2YXIgcGF0aCA9IHNlZ21lbnRzLnJlZHVjZShmdW5jdGlvbiAocGF0aCwgc2VnbWVudCkge1xuICAgIHZhciBfYSwgX2I7XG5cbiAgICB2YXIgc2VnbWVudFBhdGggPSAoX2IgPSAoX2EgPSBzZWdtZW50LnBhcnNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJ1aWxkKHBhcmFtcywge1xuICAgICAgaWdub3JlU2VhcmNoOiB0cnVlLFxuICAgICAgcXVlcnlQYXJhbXM6IG9wdGlvbnMucXVlcnlQYXJhbXMsXG4gICAgICB1cmxQYXJhbXNFbmNvZGluZzogb3B0aW9ucy51cmxQYXJhbXNFbmNvZGluZ1xuICAgIH0pLCBfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyk7XG4gICAgcmV0dXJuIHNlZ21lbnQuYWJzb2x1dGUgPyBzZWdtZW50UGF0aCA6IHBhdGggKyBzZWdtZW50UGF0aDtcbiAgfSwgJycpIC8vIHJlbW92ZSByZXBlYXRlZCBzbGFzaGVzXG4gIC5yZXBsYWNlKC9cXC9cXC97MSx9L2csICcvJyk7XG4gIHZhciBmaW5hbFBhdGggPSBwYXRoO1xuXG4gIGlmICh0cmFpbGluZ1NsYXNoTW9kZSA9PT0gJ2Fsd2F5cycpIHtcbiAgICBmaW5hbFBhdGggPSAvXFwvJC8udGVzdChwYXRoKSA/IHBhdGggOiBwYXRoICsgXCIvXCI7XG4gIH0gZWxzZSBpZiAodHJhaWxpbmdTbGFzaE1vZGUgPT09ICduZXZlcicgJiYgcGF0aCAhPT0gJy8nKSB7XG4gICAgZmluYWxQYXRoID0gL1xcLyQvLnRlc3QocGF0aCkgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG4gIH1cblxuICByZXR1cm4gZmluYWxQYXRoICsgKHNlYXJjaFBhcnQgPyAnPycgKyBzZWFyY2hQYXJ0IDogJycpO1xufTtcbnZhciBnZXRQYXRoRnJvbVNlZ21lbnRzID0gZnVuY3Rpb24gZ2V0UGF0aEZyb21TZWdtZW50cyhzZWdtZW50cykge1xuICByZXR1cm4gc2VnbWVudHMgPyBzZWdtZW50cy5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gc2VnbWVudC5wYXRoO1xuICB9KS5qb2luKCcnKSA6IG51bGw7XG59O1xuXG52YXIgZ2V0UGF0aCA9IGZ1bmN0aW9uIGdldFBhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5zcGxpdCgnPycpWzBdO1xufTtcblxudmFyIGdldFNlYXJjaCA9IGZ1bmN0aW9uIGdldFNlYXJjaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnNwbGl0KCc/JylbMV0gfHwgJyc7XG59O1xuXG52YXIgbWF0Y2hDaGlsZHJlbiA9IGZ1bmN0aW9uIG1hdGNoQ2hpbGRyZW4obm9kZXMsIHBhdGhTZWdtZW50LCBjdXJyZW50TWF0Y2gsIG9wdGlvbnMsIGNvbnN1bWVkQmVmb3JlKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2EgPSBvcHRpb25zLnF1ZXJ5UGFyYW1zTW9kZSxcbiAgICAgIHF1ZXJ5UGFyYW1zTW9kZSA9IF9hID09PSB2b2lkIDAgPyAnZGVmYXVsdCcgOiBfYSxcbiAgICAgIF9iID0gb3B0aW9ucy5zdHJpY3RUcmFpbGluZ1NsYXNoLFxuICAgICAgc3RyaWN0VHJhaWxpbmdTbGFzaCA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLFxuICAgICAgX2MgPSBvcHRpb25zLnN0cm9uZ01hdGNoaW5nLFxuICAgICAgc3Ryb25nTWF0Y2hpbmcgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLFxuICAgICAgX2QgPSBvcHRpb25zLmNhc2VTZW5zaXRpdmUsXG4gICAgICBjYXNlU2Vuc2l0aXZlID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Q7XG4gIHZhciBpc1Jvb3QgPSBub2Rlcy5sZW5ndGggPT09IDEgJiYgbm9kZXNbMF0ubmFtZSA9PT0gJyc7XG5cbiAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiBfbG9vcF8xKGNoaWxkKSB7XG4gICAgLy8gUGFydGlhbGx5IG1hdGNoIHBhdGhcbiAgICB2YXIgbWF0Y2ggPSBudWxsO1xuICAgIHZhciByZW1haW5pbmdQYXRoID0gdm9pZCAwO1xuICAgIHZhciBzZWdtZW50ID0gcGF0aFNlZ21lbnQ7XG5cbiAgICBpZiAoY29uc3VtZWRCZWZvcmUgPT09ICcvJyAmJiBjaGlsZC5wYXRoID09PSAnLycpIHtcbiAgICAgIC8vIHdoZW4gd2UgZW5jb3VudGVyIHJlcGVhdGluZyBzbGFzaGVzIHdlIGFkZCB0aGUgc2xhc2hcbiAgICAgIC8vIGJhY2sgdG8gdGhlIFVSTCB0byBtYWtlIGl0IGRlIGZhY3RvIHBhdGhsZXNzXG4gICAgICBzZWdtZW50ID0gJy8nICsgcGF0aFNlZ21lbnQ7XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIG1hdGNoID0gY2hpbGQucGFyc2VyLnRlc3Qoc2VnbWVudCwge1xuICAgICAgICBjYXNlU2Vuc2l0aXZlOiBjYXNlU2Vuc2l0aXZlLFxuICAgICAgICBzdHJpY3RUcmFpbGluZ1NsYXNoOiBzdHJpY3RUcmFpbGluZ1NsYXNoLFxuICAgICAgICBxdWVyeVBhcmFtczogb3B0aW9ucy5xdWVyeVBhcmFtcyxcbiAgICAgICAgdXJsUGFyYW1zRW5jb2Rpbmc6IG9wdGlvbnMudXJsUGFyYW1zRW5jb2RpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gY2hpbGQucGFyc2VyLnBhcnRpYWxUZXN0KHNlZ21lbnQsIHtcbiAgICAgICAgZGVsaW1pdGVkOiBzdHJvbmdNYXRjaGluZyxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgcXVlcnlQYXJhbXM6IG9wdGlvbnMucXVlcnlQYXJhbXMsXG4gICAgICAgIHVybFBhcmFtc0VuY29kaW5nOiBvcHRpb25zLnVybFBhcmFtc0VuY29kaW5nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIC8vIFJlbW92ZSBjb25zdW1lZCBzZWdtZW50IGZyb20gcGF0aFxuICAgICAgdmFyIGNvbnN1bWVkUGF0aCA9IGNoaWxkLnBhcnNlci5idWlsZChtYXRjaCwge1xuICAgICAgICBpZ25vcmVTZWFyY2g6IHRydWUsXG4gICAgICAgIHVybFBhcmFtc0VuY29kaW5nOiBvcHRpb25zLnVybFBhcmFtc0VuY29kaW5nXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzdHJpY3RUcmFpbGluZ1NsYXNoICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3VtZWRQYXRoID0gY29uc3VtZWRQYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICB9IC8vIENhbid0IGNyZWF0ZSBhIHJlZ2V4cCBmcm9tIHRoZSBwYXRoIGJlY2F1c2UgaXQgbWlnaHQgY29udGFpbiBhXG4gICAgICAvLyByZWdleHAgY2hhcmFjdGVyLlxuXG5cbiAgICAgIGlmIChzZWdtZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihjb25zdW1lZFBhdGgudG9Mb3dlckNhc2UoKSkgPT09IDApIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aCA9IHNlZ21lbnQuc2xpY2UoY29uc3VtZWRQYXRoLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRoID0gc2VnbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdHJpY3RUcmFpbGluZ1NsYXNoICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aCA9IHJlbWFpbmluZ1BhdGgucmVwbGFjZSgvXlxcL1xcPy8sICc/Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWVyeXN0cmluZyA9IG9taXQoZ2V0U2VhcmNoKHNlZ21lbnQucmVwbGFjZShjb25zdW1lZFBhdGgsICcnKSksIGNoaWxkLnBhcnNlci5xdWVyeVBhcmFtcywgb3B0aW9ucy5xdWVyeVBhcmFtcykucXVlcnlzdHJpbmc7XG4gICAgICByZW1haW5pbmdQYXRoID0gZ2V0UGF0aChyZW1haW5pbmdQYXRoKSArIChxdWVyeXN0cmluZyA/IFwiP1wiICsgcXVlcnlzdHJpbmcgOiAnJyk7XG5cbiAgICAgIGlmICghc3RyaWN0VHJhaWxpbmdTbGFzaCAmJiAhaXNSb290ICYmIHJlbWFpbmluZ1BhdGggPT09ICcvJyAmJiAhL1xcLyQvLnRlc3QoY29uc3VtZWRQYXRoKSkge1xuICAgICAgICByZW1haW5pbmdQYXRoID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRNYXRjaC5zZWdtZW50cy5wdXNoKGNoaWxkKTtcbiAgICAgIE9iamVjdC5rZXlzKG1hdGNoKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICByZXR1cm4gY3VycmVudE1hdGNoLnBhcmFtc1twYXJhbV0gPSBtYXRjaFtwYXJhbV07XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFpc1Jvb3QgJiYgIXJlbWFpbmluZ1BhdGgubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRNYXRjaFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUm9vdCAmJiBxdWVyeVBhcmFtc01vZGUgIT09ICdzdHJpY3QnICYmIHJlbWFpbmluZ1BhdGguaW5kZXhPZignPycpID09PSAwKSB7XG4gICAgICAgIC8vIHVubWF0Y2hlZCBxdWVyeVBhcmFtcyBpbiBub24gc3RyaWN0IG1vZGVcbiAgICAgICAgdmFyIHJlbWFpbmluZ1F1ZXJ5UGFyYW1zXzEgPSBwYXJzZShyZW1haW5pbmdQYXRoLnNsaWNlKDEpLCBvcHRpb25zLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgT2JqZWN0LmtleXMocmVtYWluaW5nUXVlcnlQYXJhbXNfMSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TWF0Y2gucGFyYW1zW25hbWVdID0gcmVtYWluaW5nUXVlcnlQYXJhbXNfMVtuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRNYXRjaFxuICAgICAgICB9O1xuICAgICAgfSAvLyBDb250aW51ZSBtYXRjaGluZyBvbiBub24gYWJzb2x1dGUgY2hpbGRyZW5cblxuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBjaGlsZC5nZXROb25BYnNvbHV0ZUNoaWxkcmVuKCk7IC8vIElmIG5vIGNoaWxkcmVuIHRvIG1hdGNoIGFnYWluc3QgYnV0IHVubWF0Y2hlZCBwYXRoIGxlZnRcblxuICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbWF0Y2hDaGlsZHJlbihjaGlsZHJlbiwgcmVtYWluaW5nUGF0aCwgY3VycmVudE1hdGNoLCBvcHRpb25zLCBjb25zdW1lZFBhdGgpXG4gICAgICB9O1xuICAgIH1cbiAgfTsgLy8gZm9yIChjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG5cblxuICBmb3IgKHZhciBfaSA9IDAsIG5vZGVzXzEgPSBub2RlczsgX2kgPCBub2Rlc18xLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBjaGlsZCA9IG5vZGVzXzFbX2ldO1xuXG4gICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKGNoaWxkKTtcblxuICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIHN0YXRlXzEudmFsdWU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHNvcnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgb3JpZ2luYWxDaGlsZHJlbiA9IGNoaWxkcmVuLnNsaWNlKDApO1xuICByZXR1cm4gY2hpbGRyZW4uc29ydChzb3J0UHJlZGljYXRlKG9yaWdpbmFsQ2hpbGRyZW4pKTtcbn1cblxudmFyIHNvcnRQcmVkaWNhdGUgPSBmdW5jdGlvbiBzb3J0UHJlZGljYXRlKG9yaWdpbmFsQ2hpbGRyZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuXG4gICAgdmFyIGxlZnRQYXRoID0gbGVmdC5wYXRoLnJlcGxhY2UoLzwuKj8+L2csICcnKS5zcGxpdCgnPycpWzBdLnJlcGxhY2UoLyguKylcXC8kLywgJyQxJyk7XG4gICAgdmFyIHJpZ2h0UGF0aCA9IHJpZ2h0LnBhdGgucmVwbGFjZSgvPC4qPz4vZywgJycpLnNwbGl0KCc/JylbMF0ucmVwbGFjZSgvKC4rKVxcLyQvLCAnJDEnKTsgLy8gJy8nIGxhc3RcblxuICAgIGlmIChsZWZ0UGF0aCA9PT0gJy8nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRQYXRoID09PSAnLycpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IC8vIFNwYXQgcGFyYW1zIGxhc3RcblxuXG4gICAgaWYgKChfYSA9IGxlZnQucGFyc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzU3BhdFBhcmFtKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoKF9iID0gcmlnaHQucGFyc2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGFzU3BhdFBhcmFtKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAvLyBObyBzcGF0LCBudW1iZXIgb2Ygc2VnbWVudHMgKGxlc3Mgc2VnbWVudHMgbGFzdClcblxuXG4gICAgdmFyIGxlZnRTZWdtZW50cyA9IChsZWZ0UGF0aC5tYXRjaCgvXFwvL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgdmFyIHJpZ2h0U2VnbWVudHMgPSAocmlnaHRQYXRoLm1hdGNoKC9cXC8vZykgfHwgW10pLmxlbmd0aDtcblxuICAgIGlmIChsZWZ0U2VnbWVudHMgPCByaWdodFNlZ21lbnRzKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAobGVmdFNlZ21lbnRzID4gcmlnaHRTZWdtZW50cykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gLy8gU2FtZSBudW1iZXIgb2Ygc2VnbWVudHMsIG51bWJlciBvZiBVUkwgcGFyYW1zIGFzY2VuZGluZ1xuXG5cbiAgICB2YXIgbGVmdFBhcmFtc0NvdW50ID0gKF9kID0gKF9jID0gbGVmdC5wYXJzZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmxQYXJhbXMubGVuZ3RoLCBfZCAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKTtcbiAgICB2YXIgcmlnaHRQYXJhbXNDb3VudCA9IChfZiA9IChfZSA9IHJpZ2h0LnBhcnNlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnVybFBhcmFtcy5sZW5ndGgsIF9mICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDApO1xuXG4gICAgaWYgKGxlZnRQYXJhbXNDb3VudCA8IHJpZ2h0UGFyYW1zQ291bnQpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAobGVmdFBhcmFtc0NvdW50ID4gcmlnaHRQYXJhbXNDb3VudCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSAvLyBTYW1lIG51bWJlciBvZiBzZWdtZW50cyBhbmQgcGFyYW1zLCBsYXN0IHNlZ21lbnQgbGVuZ3RoIGRlc2NlbmRpbmdcblxuXG4gICAgdmFyIGxlZnRQYXJhbUxlbmd0aCA9IChsZWZ0UGF0aC5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSB8fCAnJykubGVuZ3RoO1xuICAgIHZhciByaWdodFBhcmFtTGVuZ3RoID0gKHJpZ2h0UGF0aC5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSB8fCAnJykubGVuZ3RoO1xuXG4gICAgaWYgKGxlZnRQYXJhbUxlbmd0aCA8IHJpZ2h0UGFyYW1MZW5ndGgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmIChsZWZ0UGFyYW1MZW5ndGggPiByaWdodFBhcmFtTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAvLyBTYW1lIGxhc3Qgc2VnbWVudCBsZW5ndGgsIHByZXNlcnZlIGRlZmluaXRpb24gb3JkZXIuIE5vdGUgdGhhdCB3ZVxuICAgIC8vIGNhbm5vdCBqdXN0IHJldHVybiAwLCBhcyBzb3J0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGEgc3RhYmxlIHNvcnQuXG5cblxuICAgIHJldHVybiBvcmlnaW5hbENoaWxkcmVuLmluZGV4T2YobGVmdCkgLSBvcmlnaW5hbENoaWxkcmVuLmluZGV4T2YocmlnaHQpO1xuICB9O1xufTtcblxudmFyIFJvdXRlTm9kZSA9XG4vKiNfX1BVUkVfXyovXG5cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUm91dGVOb2RlKG5hbWUsIHBhdGgsIGNoaWxkUm91dGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgbmFtZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRSb3V0ZXMgPT09IHZvaWQgMCkge1xuICAgICAgY2hpbGRSb3V0ZXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmFic29sdXRlID0gL15+Ly50ZXN0KHBhdGgpO1xuICAgIHRoaXMucGF0aCA9IHRoaXMuYWJzb2x1dGUgPyBwYXRoLnNsaWNlKDEpIDogcGF0aDtcbiAgICB0aGlzLnBhcnNlciA9IHRoaXMucGF0aCA/IG5ldyBQYXRoKHRoaXMucGF0aCkgOiBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIHRoaXMuY2hlY2tQYXJlbnRzKCk7XG4gICAgdGhpcy5hZGQoY2hpbGRSb3V0ZXMsIG9wdGlvbnMub25BZGQsIG9wdGlvbnMuZmluYWxTb3J0ID8gZmFsc2UgOiBvcHRpb25zLnNvcnQgIT09IGZhbHNlKTtcblxuICAgIGlmIChvcHRpb25zLmZpbmFsU29ydCkge1xuICAgICAgdGhpcy5zb3J0RGVzY2VuZGFudHMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIFJvdXRlTm9kZS5wcm90b3R5cGUuZ2V0UGFyZW50U2VnbWVudHMgPSBmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICBpZiAoc2VnbWVudHMgPT09IHZvaWQgMCkge1xuICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyc2VyID8gdGhpcy5wYXJlbnQuZ2V0UGFyZW50U2VnbWVudHMoc2VnbWVudHMuY29uY2F0KHRoaXMucGFyZW50KSkgOiBzZWdtZW50cy5yZXZlcnNlKCk7XG4gIH07XG5cbiAgUm91dGVOb2RlLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5jaGVja1BhcmVudHMoKTtcbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMucGFyc2VyID0gcGF0aCA/IG5ldyBQYXRoKHBhdGgpIDogbnVsbDtcbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChyb3V0ZSwgY2IsIHNvcnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHNvcnQgPT09IHZvaWQgMCkge1xuICAgICAgc29ydCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJvdXRlID09PSB1bmRlZmluZWQgfHwgcm91dGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyb3V0ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByb3V0ZS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5hZGQociwgY2IsIHNvcnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIShyb3V0ZSBpbnN0YW5jZW9mIFJvdXRlTm9kZSkgJiYgIShyb3V0ZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUm91dGVOb2RlLmFkZCgpIGV4cGVjdHMgcm91dGVzIHRvIGJlIGFuIE9iamVjdCBvciBhbiBpbnN0YW5jZSBvZiBSb3V0ZU5vZGUuJyk7XG4gICAgfSBlbHNlIGlmIChyb3V0ZSBpbnN0YW5jZW9mIFJvdXRlTm9kZSkge1xuICAgICAgcm91dGUuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgdGhpcy5hZGRSb3V0ZU5vZGUocm91dGUsIHNvcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJvdXRlLm5hbWUgfHwgIXJvdXRlLnBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb3V0ZU5vZGUuYWRkKCkgZXhwZWN0cyByb3V0ZXMgdG8gaGF2ZSBhIG5hbWUgYW5kIGEgcGF0aCBkZWZpbmVkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm91dGVOb2RlID0gbmV3IFJvdXRlTm9kZShyb3V0ZS5uYW1lLCByb3V0ZS5wYXRoLCByb3V0ZS5jaGlsZHJlbiwge1xuICAgICAgICBmaW5hbFNvcnQ6IGZhbHNlLFxuICAgICAgICBvbkFkZDogY2IsXG4gICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgc29ydDogc29ydFxuICAgICAgfSk7XG4gICAgICB2YXIgZnVsbE5hbWUgPSByb3V0ZU5vZGUuZ2V0UGFyZW50U2VnbWVudHMoW3JvdXRlTm9kZV0pLm1hcChmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gXy5uYW1lO1xuICAgICAgfSkuam9pbignLicpO1xuXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IoX19hc3NpZ24oX19hc3NpZ24oe30sIHJvdXRlKSwge1xuICAgICAgICAgIG5hbWU6IGZ1bGxOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRSb3V0ZU5vZGUocm91dGVOb2RlLCBzb3J0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiAobmFtZSwgcGF0aCkge1xuICAgIHRoaXMuYWRkKG5ldyBSb3V0ZU5vZGUobmFtZSwgcGF0aCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFJvdXRlTm9kZS5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uIChyb3V0ZU5hbWUpIHtcbiAgICB2YXIgc2VnbWVudHNCeU5hbWUgPSB0aGlzLmdldFNlZ21lbnRzQnlOYW1lKHJvdXRlTmFtZSk7XG4gICAgcmV0dXJuIHNlZ21lbnRzQnlOYW1lID8gZ2V0UGF0aEZyb21TZWdtZW50cyhzZWdtZW50c0J5TmFtZSkgOiBudWxsO1xuICB9O1xuXG4gIFJvdXRlTm9kZS5wcm90b3R5cGUuZ2V0Tm9uQWJzb2x1dGVDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gIWNoaWxkLmFic29sdXRlO1xuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlTm9kZS5wcm90b3R5cGUuc29ydENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgc29ydENoaWxkcmVuKHRoaXMuY2hpbGRyZW4pO1xuICAgIH1cbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLnNvcnREZXNjZW5kYW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNvcnRDaGlsZHJlbigpO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5zb3J0RGVzY2VuZGFudHMoKTtcbiAgICB9KTtcbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChyb3V0ZU5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzZWdtZW50cyA9IHRoaXMuZ2V0U2VnbWVudHNCeU5hbWUocm91dGVOYW1lKTtcblxuICAgIGlmICghc2VnbWVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltyb3V0ZS1ub2RlXVtidWlsZFBhdGhdICd7cm91dGVOYW1lfScgaXMgbm90IGRlZmluZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkUGF0aEZyb21TZWdtZW50cyhzZWdtZW50cywgcGFyYW1zLCBvcHRpb25zKTtcbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLmJ1aWxkU3RhdGUgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLmdldFNlZ21lbnRzQnlOYW1lKG5hbWUpO1xuXG4gICAgaWYgKCFzZWdtZW50cyB8fCAhc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgbWV0YTogZ2V0TWV0YUZyb21TZWdtZW50cyhzZWdtZW50cylcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlTm9kZS5wcm90b3R5cGUubWF0Y2hQYXRoID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHBhdGggPT09ICcnICYmICFvcHRpb25zLnN0cmljdFRyYWlsaW5nU2xhc2gpIHtcbiAgICAgIHBhdGggPSAnLyc7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gdGhpcy5nZXRTZWdtZW50c01hdGNoaW5nUGF0aChwYXRoLCBvcHRpb25zKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGVkU2VnbWVudHMgPSBtYXRjaC5zZWdtZW50cztcblxuICAgIGlmIChtYXRjaGVkU2VnbWVudHNbMF0uYWJzb2x1dGUpIHtcbiAgICAgIHZhciBmaXJzdFNlZ21lbnRQYXJhbXMgPSBtYXRjaGVkU2VnbWVudHNbMF0uZ2V0UGFyZW50U2VnbWVudHMoKTtcbiAgICAgIG1hdGNoZWRTZWdtZW50cy5yZXZlcnNlKCk7XG4gICAgICBtYXRjaGVkU2VnbWVudHMucHVzaC5hcHBseShtYXRjaGVkU2VnbWVudHMsIGZpcnN0U2VnbWVudFBhcmFtcyk7XG4gICAgICBtYXRjaGVkU2VnbWVudHMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHZhciBsYXN0U2VnbWVudCA9IG1hdGNoZWRTZWdtZW50c1ttYXRjaGVkU2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGxhc3RTZWdtZW50U2xhc2hDaGlsZCA9IGxhc3RTZWdtZW50LmZpbmRTbGFzaENoaWxkKCk7XG5cbiAgICBpZiAobGFzdFNlZ21lbnRTbGFzaENoaWxkKSB7XG4gICAgICBtYXRjaGVkU2VnbWVudHMucHVzaChsYXN0U2VnbWVudFNsYXNoQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZFN0YXRlRnJvbU1hdGNoKG1hdGNoKTtcbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLmFkZFJvdXRlTm9kZSA9IGZ1bmN0aW9uIChyb3V0ZSwgc29ydCkge1xuICAgIGlmIChzb3J0ID09PSB2b2lkIDApIHtcbiAgICAgIHNvcnQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IHJvdXRlLm5hbWUuc3BsaXQoJy4nKTtcblxuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIENoZWNrIGR1cGxpY2F0ZWQgcm91dGVzXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5uYW1lO1xuICAgICAgfSkuaW5kZXhPZihyb3V0ZS5uYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxpYXMgXFxcIlwiICsgcm91dGUubmFtZSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gcm91dGUgbm9kZVwiKTtcbiAgICAgIH0gLy8gQ2hlY2sgZHVwbGljYXRlZCBwYXRoc1xuXG5cbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLnBhdGg7XG4gICAgICB9KS5pbmRleE9mKHJvdXRlLnBhdGgpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIFxcXCJcIiArIHJvdXRlLnBhdGggKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIHJvdXRlIG5vZGVcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChyb3V0ZSk7XG5cbiAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgIHRoaXMuc29ydENoaWxkcmVuKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExvY2F0ZSBwYXJlbnQgbm9kZVxuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5nZXRTZWdtZW50c0J5TmFtZShuYW1lcy5zbGljZSgwLCAtMSkuam9pbignLicpKTtcblxuICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgIHJvdXRlLm5hbWUgPSBuYW1lc1tuYW1lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uYWRkKHJvdXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBhZGQgcm91dGUgbmFtZWQgJ1wiICsgcm91dGUubmFtZSArIFwiJywgcGFyZW50IGlzIG1pc3NpbmcuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFJvdXRlTm9kZS5wcm90b3R5cGUuY2hlY2tQYXJlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFic29sdXRlICYmIHRoaXMuaGFzUGFyZW50c1BhcmFtcygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tSb3V0ZU5vZGVdIEEgUm91dGVOb2RlIHdpdGggYW4gYWJvbHV0ZSBwYXRoIGNhbm5vdCBoYXZlIHBhcmVudHMgd2l0aCByb3V0ZSBwYXJhbWV0ZXJzJyk7XG4gICAgfVxuICB9O1xuXG4gIFJvdXRlTm9kZS5wcm90b3R5cGUuaGFzUGFyZW50c1BhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyc2VyKSB7XG4gICAgICB2YXIgcGFyc2VyID0gdGhpcy5wYXJlbnQucGFyc2VyO1xuICAgICAgdmFyIGhhc1BhcmFtcyA9IHBhcnNlci5oYXNVcmxQYXJhbXMgfHwgcGFyc2VyLmhhc1NwYXRQYXJhbSB8fCBwYXJzZXIuaGFzTWF0cml4UGFyYW1zIHx8IHBhcnNlci5oYXNRdWVyeVBhcmFtcztcbiAgICAgIHJldHVybiBoYXNQYXJhbXMgfHwgdGhpcy5wYXJlbnQuaGFzUGFyZW50c1BhcmFtcygpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLmZpbmRBYnNvbHV0ZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoYWJzb2x1dGVDaGlsZHJlbiwgY2hpbGQpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0ZUNoaWxkcmVuLmNvbmNhdChjaGlsZC5hYnNvbHV0ZSA/IGNoaWxkIDogW10pLmNvbmNhdChjaGlsZC5maW5kQWJzb2x1dGVDaGlsZHJlbigpKTtcbiAgICB9LCBbXSk7XG4gIH07XG5cbiAgUm91dGVOb2RlLnByb3RvdHlwZS5maW5kU2xhc2hDaGlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2xhc2hDaGlsZHJlbiA9IHRoaXMuZ2V0Tm9uQWJzb2x1dGVDaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5wYXJzZXIgJiYgL15cXC8oXFw/fCQpLy50ZXN0KGNoaWxkLnBhcnNlci5wYXRoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2xhc2hDaGlsZHJlblswXTtcbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLmdldFNlZ21lbnRzQnlOYW1lID0gZnVuY3Rpb24gKHJvdXRlTmFtZSkge1xuICAgIHZhciBmaW5kU2VnbWVudEJ5TmFtZSA9IGZ1bmN0aW9uIGZpbmRTZWdtZW50QnlOYW1lKG5hbWUsIHJvdXRlcykge1xuICAgICAgdmFyIGZpbHRlcmVkUm91dGVzID0gcm91dGVzLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gci5uYW1lID09PSBuYW1lO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWRSb3V0ZXMubGVuZ3RoID8gZmlsdGVyZWRSb3V0ZXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgIHZhciByb3V0ZXMgPSB0aGlzLnBhcnNlciA/IFt0aGlzXSA6IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIG5hbWVzID0gKHRoaXMucGFyc2VyID8gWycnXSA6IFtdKS5jb25jYXQocm91dGVOYW1lLnNwbGl0KCcuJykpO1xuICAgIHZhciBtYXRjaGVkID0gbmFtZXMuZXZlcnkoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gZmluZFNlZ21lbnRCeU5hbWUobmFtZSwgcm91dGVzKTtcblxuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcm91dGVzID0gc2VnbWVudC5jaGlsZHJlbjtcbiAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWF0Y2hlZCA/IHNlZ21lbnRzIDogbnVsbDtcbiAgfTtcblxuICBSb3V0ZU5vZGUucHJvdG90eXBlLmdldFNlZ21lbnRzTWF0Y2hpbmdQYXRoID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgdG9wTGV2ZWxOb2RlcyA9IHRoaXMucGFyc2VyID8gW3RoaXNdIDogdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgc3RhcnRpbmdOb2RlcyA9IHRvcExldmVsTm9kZXMucmVkdWNlKGZ1bmN0aW9uIChub2Rlcywgbm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGVzLmNvbmNhdChub2RlLCBub2RlLmZpbmRBYnNvbHV0ZUNoaWxkcmVuKCkpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgY3VycmVudE1hdGNoID0ge1xuICAgICAgc2VnbWVudHM6IFtdLFxuICAgICAgcGFyYW1zOiB7fVxuICAgIH07XG4gICAgdmFyIGZpbmFsTWF0Y2ggPSBtYXRjaENoaWxkcmVuKHN0YXJ0aW5nTm9kZXMsIHBhdGgsIGN1cnJlbnRNYXRjaCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoZmluYWxNYXRjaCAmJiBmaW5hbE1hdGNoLnNlZ21lbnRzLmxlbmd0aCA9PT0gMSAmJiBmaW5hbE1hdGNoLnNlZ21lbnRzWzBdLm5hbWUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluYWxNYXRjaDtcbiAgfTtcblxuICByZXR1cm4gUm91dGVOb2RlO1xufSgpO1xuXG5leHBvcnQgeyBSb3V0ZU5vZGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlLW5vZGUuZXNtLmpzLm1hcFxuIiwiaW1wb3J0IHsgZXJyb3JDb2RlcywgY29uc3RhbnRzIH0gZnJvbSAncm91dGVyNSc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxuXG52YXIgdmFsdWUgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcmc7IH07IH07XHJcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xyXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhpc3Rvcnk7XHJcbnZhciBnZXRCYXNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lOyB9O1xyXG52YXIgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgPT09IC0xO1xyXG59O1xyXG52YXIgcHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHBhdGgpO1xyXG59O1xyXG52YXIgcmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHBhdGgpO1xyXG59O1xyXG52YXIgYWRkUG9wc3RhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xyXG4gICAgdmFyIHNob3VsZEFkZEhhc2hDaGFuZ2VMaXN0ZW5lciA9IG9wdHMudXNlSGFzaCAmJiAhc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZm4pO1xyXG4gICAgaWYgKHNob3VsZEFkZEhhc2hDaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZm4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmbik7XHJcbiAgICAgICAgaWYgKHNob3VsZEFkZEhhc2hDaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG52YXIgZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgdmFyIHBhdGggPSBvcHRzLnVzZUhhc2hcclxuICAgICAgICA/IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiMnICsgb3B0cy5oYXNoUHJlZml4KSwgJycpXHJcbiAgICAgICAgOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIG9wdHMuYmFzZSksICcnKTtcclxuICAgIC8vIEZpeCBpc3N1ZSB3aXRoIGJyb3dzZXJzIHRoYXQgZG9uJ3QgVVJMIGVuY29kZSBjaGFyYWN0ZXJzIChFZGdlKVxyXG4gICAgdmFyIGNvcnJlY3RlZFBhdGggPSBzYWZlbHlFbmNvZGVQYXRoKHBhdGgpO1xyXG4gICAgcmV0dXJuIChjb3JyZWN0ZWRQYXRoIHx8ICcvJykgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xyXG59O1xyXG52YXIgc2FmZWx5RW5jb2RlUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBlbmNvZGVVUkkoZGVjb2RlVVJJKHBhdGgpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChfKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcbn07XHJcbnZhciBnZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlOyB9O1xyXG52YXIgZ2V0SGFzaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoOyB9O1xyXG52YXIgYnJvd3NlciA9IHt9O1xyXG5pZiAoaXNCcm93c2VyKSB7XHJcbiAgICBicm93c2VyID0ge1xyXG4gICAgICAgIGdldEJhc2U6IGdldEJhc2UsXHJcbiAgICAgICAgcHVzaFN0YXRlOiBwdXNoU3RhdGUsXHJcbiAgICAgICAgcmVwbGFjZVN0YXRlOiByZXBsYWNlU3RhdGUsXHJcbiAgICAgICAgYWRkUG9wc3RhdGVMaXN0ZW5lcjogYWRkUG9wc3RhdGVMaXN0ZW5lcixcclxuICAgICAgICBnZXRMb2NhdGlvbjogZ2V0TG9jYXRpb24sXHJcbiAgICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxyXG4gICAgICAgIGdldEhhc2g6IGdldEhhc2hcclxuICAgIH07XHJcbn1cclxuZWxzZSB7XHJcbiAgICBicm93c2VyID0ge1xyXG4gICAgICAgIGdldEJhc2U6IHZhbHVlKCcnKSxcclxuICAgICAgICBwdXNoU3RhdGU6IG5vb3AsXHJcbiAgICAgICAgcmVwbGFjZVN0YXRlOiBub29wLFxyXG4gICAgICAgIGFkZFBvcHN0YXRlTGlzdGVuZXI6IG5vb3AsXHJcbiAgICAgICAgZ2V0TG9jYXRpb246IHZhbHVlKCcnKSxcclxuICAgICAgICBnZXRTdGF0ZTogdmFsdWUobnVsbCksXHJcbiAgICAgICAgZ2V0SGFzaDogdmFsdWUoJycpXHJcbiAgICB9O1xyXG59XHJcbnZhciBzYWZlQnJvd3NlciA9IGJyb3dzZXI7XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgIGZvcmNlRGVhY3RpdmF0ZTogdHJ1ZSxcclxuICAgIHVzZUhhc2g6IGZhbHNlLFxyXG4gICAgaGFzaFByZWZpeDogJycsXHJcbiAgICBiYXNlOiAnJyxcclxuICAgIG1lcmdlU3RhdGU6IGZhbHNlLFxyXG4gICAgcHJlc2VydmVIYXNoOiB0cnVlXHJcbn07XHJcbnZhciBzb3VyY2UgPSAncG9wc3RhdGUnO1xyXG5mdW5jdGlvbiBicm93c2VyUGx1Z2luRmFjdG9yeShvcHRzLCBicm93c2VyKSB7XHJcbiAgICBpZiAoYnJvd3NlciA9PT0gdm9pZCAwKSB7IGJyb3dzZXIgPSBzYWZlQnJvd3NlcjsgfVxyXG4gICAgdmFyIG9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMpLCBvcHRzKTtcclxuICAgIHZhciB0cmFuc2l0aW9uT3B0aW9ucyA9IHtcclxuICAgICAgICBmb3JjZURlYWN0aXZhdGU6IG9wdGlvbnMuZm9yY2VEZWFjdGl2YXRlLFxyXG4gICAgICAgIHNvdXJjZTogc291cmNlXHJcbiAgICB9O1xyXG4gICAgdmFyIHJlbW92ZVBvcFN0YXRlTGlzdGVuZXI7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gYnJvd3NlclBsdWdpbihyb3V0ZXIpIHtcclxuICAgICAgICB2YXIgcm91dGVyT3B0aW9ucyA9IHJvdXRlci5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgdmFyIHJvdXRlclN0YXJ0ID0gcm91dGVyLnN0YXJ0O1xyXG4gICAgICAgIHJvdXRlci5idWlsZFVybCA9IGZ1bmN0aW9uIChyb3V0ZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXNlID0gb3B0aW9ucy5iYXNlIHx8ICcnO1xyXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy51c2VIYXNoID8gXCIjXCIgKyBvcHRpb25zLmhhc2hQcmVmaXggOiAnJztcclxuICAgICAgICAgICAgdmFyIHBhdGggPSByb3V0ZXIuYnVpbGRQYXRoKHJvdXRlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmFzZSArIHByZWZpeCArIHBhdGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdXJsVG9QYXRoID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB1cmwubWF0Y2goL14oPzpodHRwfGh0dHBzKTpcXC9cXC8oPzpbMC05YS16X1xcLS46XSs/KSg/PVxcLykoLiopJC8pO1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IG1hdGNoID8gbWF0Y2hbMV0gOiB1cmw7XHJcbiAgICAgICAgICAgIHZhciBwYXRoUGFydHMgPSBwYXRoLm1hdGNoKC9eKC4rPykoIy4rPyk/KFxcPy4rKT8kLyk7XHJcbiAgICAgICAgICAgIGlmICghcGF0aFBhcnRzKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW3JvdXRlcjVdIENvdWxkIG5vdCBwYXJzZSB1cmwgXCIgKyB1cmwpO1xyXG4gICAgICAgICAgICB2YXIgcGF0aG5hbWUgPSBwYXRoUGFydHNbMV07XHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gcGF0aFBhcnRzWzJdIHx8ICcnO1xyXG4gICAgICAgICAgICB2YXIgc2VhcmNoID0gcGF0aFBhcnRzWzNdIHx8ICcnO1xyXG4gICAgICAgICAgICByZXR1cm4gKChvcHRpb25zLnVzZUhhc2hcclxuICAgICAgICAgICAgICAgID8gaGFzaC5yZXBsYWNlKG5ldyBSZWdFeHAoJ14jJyArIG9wdGlvbnMuaGFzaFByZWZpeCksICcnKVxyXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmJhc2VcclxuICAgICAgICAgICAgICAgICAgICA/IHBhdGhuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnXicgKyBvcHRpb25zLmJhc2UpLCAnJylcclxuICAgICAgICAgICAgICAgICAgICA6IHBhdGhuYW1lKSArIHNlYXJjaCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByb3V0ZXIubWF0Y2hVcmwgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiByb3V0ZXIubWF0Y2hQYXRoKHVybFRvUGF0aCh1cmwpKTsgfTtcclxuICAgICAgICByb3V0ZXIuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByb3V0ZXJTdGFydC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXlzKFticm93c2VyLmdldExvY2F0aW9uKG9wdGlvbnMpXSwgYXJncykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm91dGVyU3RhcnQuYXBwbHkodm9pZCAwLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcm91dGVyLnJlcGxhY2VIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zLCB0aXRsZSkge1xyXG4gICAgICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cclxuICAgICAgICAgICAgaWYgKHRpdGxlID09PSB2b2lkIDApIHsgdGl0bGUgPSAnJzsgfVxyXG4gICAgICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXIuYnVpbGRTdGF0ZShuYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSByb3V0ZXIubWFrZVN0YXRlKHJvdXRlLm5hbWUsIHJvdXRlLnBhcmFtcywgcm91dGVyLmJ1aWxkUGF0aChyb3V0ZS5uYW1lLCByb3V0ZS5wYXJhbXMpLCB7IHBhcmFtczogcm91dGUubWV0YSB9KTtcclxuICAgICAgICAgICAgdmFyIHVybCA9IHJvdXRlci5idWlsZFVybChuYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICByb3V0ZXIubGFzdEtub3duU3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgYnJvd3Nlci5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQnJvd3NlclN0YXRlKHN0YXRlLCB1cmwsIHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgdmFyIHRyaW1tZWRTdGF0ZSA9IHN0YXRlXHJcbiAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRhOiBzdGF0ZS5tZXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN0YXRlLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBzdGF0ZS5wYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogc3RhdGUucGF0aFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiBzdGF0ZTtcclxuICAgICAgICAgICAgdmFyIGZpbmFsU3RhdGUgPSBvcHRpb25zLm1lcmdlU3RhdGUgPT09IHRydWVcclxuICAgICAgICAgICAgICAgID8gX19hc3NpZ24oX19hc3NpZ24oe30sIGJyb3dzZXIuZ2V0U3RhdGUoKSksIHRyaW1tZWRTdGF0ZSkgOiB0cmltbWVkU3RhdGU7XHJcbiAgICAgICAgICAgIGlmIChyZXBsYWNlKVxyXG4gICAgICAgICAgICAgICAgYnJvd3Nlci5yZXBsYWNlU3RhdGUoZmluYWxTdGF0ZSwgJycsIHVybCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGJyb3dzZXIucHVzaFN0YXRlKGZpbmFsU3RhdGUsICcnLCB1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvblBvcFN0YXRlKGV2dCkge1xyXG4gICAgICAgICAgICB2YXIgcm91dGVyU3RhdGUgPSByb3V0ZXIuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBubyBzdGF0ZSBvciBpZiBsYXN0IGtub3cgc3RhdGUgaXMgcG9wZWQgc3RhdGUgKGl0IHNob3VsZCBuZXZlciBoYXBwZW4pXHJcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZSA9ICFldnQuc3RhdGUgfHwgIWV2dC5zdGF0ZS5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBuZXdTdGF0ZVxyXG4gICAgICAgICAgICAgICAgPyByb3V0ZXIubWF0Y2hQYXRoKGJyb3dzZXIuZ2V0TG9jYXRpb24ob3B0aW9ucyksIHNvdXJjZSlcclxuICAgICAgICAgICAgICAgIDogcm91dGVyLm1ha2VTdGF0ZShldnQuc3RhdGUubmFtZSwgZXZ0LnN0YXRlLnBhcmFtcywgZXZ0LnN0YXRlLnBhdGgsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldnQuc3RhdGUubWV0YSksIHsgc291cmNlOiBzb3VyY2UgfSksIGV2dC5zdGF0ZS5tZXRhLmlkKTtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRSb3V0ZSA9IHJvdXRlck9wdGlvbnMuZGVmYXVsdFJvdXRlLCBkZWZhdWx0UGFyYW1zID0gcm91dGVyT3B0aW9ucy5kZWZhdWx0UGFyYW1zO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBjdXJyZW50IHN0YXRlIGlzIGFscmVhZHkgdGhlIGRlZmF1bHQgcm91dGUsIHdlIHdpbGwgaGF2ZSBhIGRvdWJsZSBlbnRyeVxyXG4gICAgICAgICAgICAgICAgLy8gTmF2aWdhdGluZyBiYWNrIGFuZCBmb3J0aCB3aWxsIGVtaXQgU0FNRV9TVEFURVMgZXJyb3JcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRSb3V0ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlci5uYXZpZ2F0ZVRvRGVmYXVsdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbk9wdGlvbnMpLCB7IHJlbG9hZDogdHJ1ZSwgcmVwbGFjZTogdHJ1ZSB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJvdXRlclN0YXRlICYmXHJcbiAgICAgICAgICAgICAgICByb3V0ZXIuYXJlU3RhdGVzRXF1YWwoc3RhdGUsIHJvdXRlclN0YXRlLCBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb3V0ZXIudHJhbnNpdGlvblRvU3RhdGUoc3RhdGUsIHJvdXRlclN0YXRlLCB0cmFuc2l0aW9uT3B0aW9ucywgZnVuY3Rpb24gKGVyciwgdG9TdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIucmVkaXJlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZXJyLnJlZGlyZWN0LCBuYW1lXzEgPSBfYS5uYW1lLCBwYXJhbXMgPSBfYS5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlci5uYXZpZ2F0ZShuYW1lXzEsIHBhcmFtcywgX19hc3NpZ24oX19hc3NpZ24oe30sIHRyYW5zaXRpb25PcHRpb25zKSwgeyByZXBsYWNlOiB0cnVlLCBmb3JjZTogdHJ1ZSwgcmVkaXJlY3RlZDogdHJ1ZSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyci5jb2RlID09PSBlcnJvckNvZGVzLkNBTk5PVF9ERUFDVElWQVRFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSByb3V0ZXIuYnVpbGRVcmwocm91dGVyU3RhdGUubmFtZSwgcm91dGVyU3RhdGUucGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBoaXN0b3J5IHN0YXRlIHVuY2hhbmdlZCBidXQgdXNlIGN1cnJlbnQgVVJMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVCcm93c2VyU3RhdGUoc3RhdGUsIHVybCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBkbyBub3RoaW5nIG9yIGhpc3Rvcnkgd2lsbCBiZSBtZXNzZWQgdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaGlzdG9yeS5iYWNrKCk/XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSBuYXZpZ2F0aW9uIHRvIGRlZmF1bHQgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFJvdXRlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXIubmF2aWdhdGUoZGVmYXVsdFJvdXRlLCBkZWZhdWx0UGFyYW1zLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbk9wdGlvbnMpLCB7IHJlbG9hZDogdHJ1ZSwgcmVwbGFjZTogdHJ1ZSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyLmludm9rZUV2ZW50TGlzdGVuZXJzKGNvbnN0YW50cy5UUkFOU0lUSU9OX1NVQ0NFU1MsIHRvU3RhdGUsIHJvdXRlclN0YXRlLCB7IHJlcGxhY2U6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvblN0YXJ0KCkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy51c2VIYXNoICYmICFvcHRpb25zLmJhc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIEd1ZXNzIGJhc2VcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYmFzZSA9IGJyb3dzZXIuZ2V0QmFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbW92ZVBvcFN0YXRlTGlzdGVuZXIgPSBicm93c2VyLmFkZFBvcHN0YXRlTGlzdGVuZXIob25Qb3BTdGF0ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHRlYXJkb3duKCkge1xyXG4gICAgICAgICAgICBpZiAocmVtb3ZlUG9wU3RhdGVMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlUG9wU3RhdGVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlUG9wU3RhdGVMaXN0ZW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvblRyYW5zaXRpb25TdWNjZXNzKHRvU3RhdGUsIGZyb21TdGF0ZSwgb3B0cykge1xyXG4gICAgICAgICAgICB2YXIgaGlzdG9yeVN0YXRlID0gYnJvd3Nlci5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgaGFzU3RhdGUgPSBoaXN0b3J5U3RhdGUgJiZcclxuICAgICAgICAgICAgICAgIGhpc3RvcnlTdGF0ZS5tZXRhICYmXHJcbiAgICAgICAgICAgICAgICBoaXN0b3J5U3RhdGUubmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgaGlzdG9yeVN0YXRlLnBhcmFtcztcclxuICAgICAgICAgICAgdmFyIHN0YXRlc0FyZUVxdWFsID0gZnJvbVN0YXRlICYmIHJvdXRlci5hcmVTdGF0ZXNFcXVhbChmcm9tU3RhdGUsIHRvU3RhdGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgdmFyIHJlcGxhY2UgPSBvcHRzLnJlcGxhY2UgfHwgIWhhc1N0YXRlIHx8IHN0YXRlc0FyZUVxdWFsO1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gcm91dGVyLmJ1aWxkVXJsKHRvU3RhdGUubmFtZSwgdG9TdGF0ZS5wYXJhbXMpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbVN0YXRlID09PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVzZUhhc2ggPT09IGZhbHNlICYmXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByZXNlcnZlSGFzaCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdXJsICs9IGJyb3dzZXIuZ2V0SGFzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVwZGF0ZUJyb3dzZXJTdGF0ZSh0b1N0YXRlLCB1cmwsIHJlcGxhY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvblN0YXJ0OiBvblN0YXJ0LFxyXG4gICAgICAgICAgICBvblN0b3A6IHRlYXJkb3duLFxyXG4gICAgICAgICAgICB0ZWFyZG93bjogdGVhcmRvd24sXHJcbiAgICAgICAgICAgIG9uVHJhbnNpdGlvblN1Y2Nlc3M6IG9uVHJhbnNpdGlvblN1Y2Nlc3MsXHJcbiAgICAgICAgICAgIG9uUG9wU3RhdGU6IG9uUG9wU3RhdGVcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxuXG5leHBvcnQgZGVmYXVsdCBicm93c2VyUGx1Z2luRmFjdG9yeTtcbiIsInZhciBuYW1lVG9JRHMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgcmV0dXJuIG5hbWVcclxuICAgICAgICAuc3BsaXQoJy4nKVxyXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGlkcywgbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBpZHMuY29uY2F0KGlkcy5sZW5ndGggPyBpZHNbaWRzLmxlbmd0aCAtIDFdICsgJy4nICsgbmFtZSA6IG5hbWUpO1xyXG4gICAgfSwgW10pO1xyXG59O1xyXG52YXIgZXhpc3RzID0gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsOyB9O1xyXG52YXIgaGFzTWV0YVBhcmFtcyA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUgJiYgc3RhdGUubWV0YSAmJiBzdGF0ZS5tZXRhLnBhcmFtczsgfTtcclxudmFyIGV4dHJhY3RTZWdtZW50UGFyYW1zID0gZnVuY3Rpb24gKG5hbWUsIHN0YXRlKSB7XHJcbiAgICBpZiAoIWhhc01ldGFQYXJhbXMoc3RhdGUpIHx8ICFleGlzdHMoc3RhdGUubWV0YS5wYXJhbXNbbmFtZV0pKVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZS5tZXRhLnBhcmFtc1tuYW1lXSkucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHApIHtcclxuICAgICAgICBwYXJhbXNbcF0gPSBzdGF0ZS5wYXJhbXNbcF07XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH0sIHt9KTtcclxufTtcclxuZnVuY3Rpb24gdHJhbnNpdGlvblBhdGgodG9TdGF0ZSwgZnJvbVN0YXRlKSB7XHJcbiAgICB2YXIgdG9TdGF0ZU9wdGlvbnMgPSAodG9TdGF0ZS5tZXRhICYmIHRvU3RhdGUubWV0YSAmJiB0b1N0YXRlLm1ldGEub3B0aW9ucykgfHwge307XHJcbiAgICB2YXIgZnJvbVN0YXRlSWRzID0gZnJvbVN0YXRlID8gbmFtZVRvSURzKGZyb21TdGF0ZS5uYW1lKSA6IFtdO1xyXG4gICAgdmFyIHRvU3RhdGVJZHMgPSBuYW1lVG9JRHModG9TdGF0ZS5uYW1lKTtcclxuICAgIHZhciBtYXhJID0gTWF0aC5taW4oZnJvbVN0YXRlSWRzLmxlbmd0aCwgdG9TdGF0ZUlkcy5sZW5ndGgpO1xyXG4gICAgZnVuY3Rpb24gcG9pbnRPZkRpZmZlcmVuY2UoKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZnJvbVN0YXRlSWRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0b1N0YXRlSWRzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGVmdCAhPT0gcmlnaHQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaSB9O1xyXG4gICAgICAgICAgICB2YXIgbGVmdFBhcmFtcyA9IGV4dHJhY3RTZWdtZW50UGFyYW1zKGxlZnQsIHRvU3RhdGUpO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRQYXJhbXMgPSBleHRyYWN0U2VnbWVudFBhcmFtcyhyaWdodCwgZnJvbVN0YXRlKTtcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxlZnRQYXJhbXMpLmxlbmd0aCAhPT1cclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJpZ2h0UGFyYW1zKS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaSB9O1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobGVmdFBhcmFtcykubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgdmFyIGRpZmZlcmVudCA9IE9iamVjdC5rZXlzKGxlZnRQYXJhbXMpLnNvbWUoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHJpZ2h0UGFyYW1zW3BdICE9PSBsZWZ0UGFyYW1zW3BdOyB9KTtcclxuICAgICAgICAgICAgaWYgKGRpZmZlcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGkgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1heEk7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgdmFyIGk7XHJcbiAgICBpZiAoIWZyb21TdGF0ZSB8fCB0b1N0YXRlT3B0aW9ucy5yZWxvYWQpIHtcclxuICAgICAgICBpID0gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFoYXNNZXRhUGFyYW1zKGZyb21TdGF0ZSkgJiYgIWhhc01ldGFQYXJhbXModG9TdGF0ZSkpIHtcclxuICAgICAgICBpID0gMDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGkgPSBwb2ludE9mRGlmZmVyZW5jZSgpO1xyXG4gICAgfVxyXG4gICAgdmFyIHRvRGVhY3RpdmF0ZSA9IGZyb21TdGF0ZUlkcy5zbGljZShpKS5yZXZlcnNlKCk7XHJcbiAgICB2YXIgdG9BY3RpdmF0ZSA9IHRvU3RhdGVJZHMuc2xpY2UoaSk7XHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gZnJvbVN0YXRlICYmIGkgPiAwID8gZnJvbVN0YXRlSWRzW2kgLSAxXSA6ICcnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvbixcclxuICAgICAgICB0b0RlYWN0aXZhdGU6IHRvRGVhY3RpdmF0ZSxcclxuICAgICAgICB0b0FjdGl2YXRlOiB0b0FjdGl2YXRlXHJcbiAgICB9O1xyXG59XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZU5vZGUobm9kZU5hbWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodG9TdGF0ZSwgZnJvbVNhdGUpIHtcclxuICAgICAgICB2YXIgX2EgPSB0cmFuc2l0aW9uUGF0aCh0b1N0YXRlLCBmcm9tU2F0ZSksIGludGVyc2VjdGlvbiA9IF9hLmludGVyc2VjdGlvbiwgdG9BY3RpdmF0ZSA9IF9hLnRvQWN0aXZhdGUsIHRvRGVhY3RpdmF0ZVJldmVyc2VkID0gX2EudG9EZWFjdGl2YXRlO1xyXG4gICAgICAgIHZhciB0b0RlYWN0aXZhdGUgPSBfX3NwcmVhZEFycmF5cyh0b0RlYWN0aXZhdGVSZXZlcnNlZCkucmV2ZXJzZSgpO1xyXG4gICAgICAgIGlmICh0b1N0YXRlLm1ldGEub3B0aW9ucyAmJiB0b1N0YXRlLm1ldGEub3B0aW9ucy5yZWxvYWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9BY3RpdmF0ZS5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0Y2hpbmcgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9BY3RpdmF0ZS5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICB2YXIgYWN0aXZhdGVkU2VnbWVudCA9IHRvQWN0aXZhdGVbaV07XHJcbiAgICAgICAgICAgIHZhciBzYW1lTGV2ZWxEZWFjdGl2YXRlZFNlZ21lbnQgPSB0b0RlYWN0aXZhdGVbaV07XHJcbiAgICAgICAgICAgIG1hdGNoaW5nID0gYWN0aXZhdGVkU2VnbWVudCA9PT0gc2FtZUxldmVsRGVhY3RpdmF0ZWRTZWdtZW50O1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcgJiYgYWN0aXZhdGVkU2VnbWVudCA9PT0gbm9kZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbWF0Y2hpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG59XG5cbmV4cG9ydCBkZWZhdWx0IHRyYW5zaXRpb25QYXRoO1xuZXhwb3J0IHsgbmFtZVRvSURzLCBzaG91bGRVcGRhdGVOb2RlIH07XG4iLCJpbXBvcnQgeyBSb3V0ZU5vZGUgfSBmcm9tICdyb3V0ZS1ub2RlJztcbmV4cG9ydCB7IFJvdXRlTm9kZSB9IGZyb20gJ3JvdXRlLW5vZGUnO1xuaW1wb3J0ICQkb2JzZXJ2YWJsZSBmcm9tICdzeW1ib2wtb2JzZXJ2YWJsZSc7XG5pbXBvcnQgdHJhbnNpdGlvblBhdGgsIHsgbmFtZVRvSURzIH0gZnJvbSAncm91dGVyNS10cmFuc2l0aW9uLXBhdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0cmFuc2l0aW9uUGF0aCB9IGZyb20gJ3JvdXRlcjUtdHJhbnNpdGlvbi1wYXRoJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgIHRyYWlsaW5nU2xhc2hNb2RlOiAnZGVmYXVsdCcsXHJcbiAgICBxdWVyeVBhcmFtc01vZGU6ICdkZWZhdWx0JyxcclxuICAgIHN0cmljdFRyYWlsaW5nU2xhc2g6IGZhbHNlLFxyXG4gICAgYXV0b0NsZWFuVXA6IHRydWUsXHJcbiAgICBhbGxvd05vdEZvdW5kOiBmYWxzZSxcclxuICAgIHN0cm9uZ01hdGNoaW5nOiB0cnVlLFxyXG4gICAgcmV3cml0ZVBhdGhPbk1hdGNoOiB0cnVlLFxyXG4gICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXHJcbiAgICB1cmxQYXJhbXNFbmNvZGluZzogJ2RlZmF1bHQnXHJcbn07XHJcbmZ1bmN0aW9uIHdpdGhPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocm91dGVyKSB7XHJcbiAgICAgICAgdmFyIHJvdXRlck9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMpLCBvcHRpb25zKTtcclxuICAgICAgICByb3V0ZXIuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlck9wdGlvbnM7IH07XHJcbiAgICAgICAgcm91dGVyLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJvdXRlck9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJvdXRlcjtcclxuICAgIH07XHJcbn1cblxudmFyIGVycm9yQ29kZXMgPSB7XHJcbiAgICBST1VURVJfTk9UX1NUQVJURUQ6ICdOT1RfU1RBUlRFRCcsXHJcbiAgICBOT19TVEFSVF9QQVRIX09SX1NUQVRFOiAnTk9fU1RBUlRfUEFUSF9PUl9TVEFURScsXHJcbiAgICBST1VURVJfQUxSRUFEWV9TVEFSVEVEOiAnQUxSRUFEWV9TVEFSVEVEJyxcclxuICAgIFJPVVRFX05PVF9GT1VORDogJ1JPVVRFX05PVF9GT1VORCcsXHJcbiAgICBTQU1FX1NUQVRFUzogJ1NBTUVfU1RBVEVTJyxcclxuICAgIENBTk5PVF9ERUFDVElWQVRFOiAnQ0FOTk9UX0RFQUNUSVZBVEUnLFxyXG4gICAgQ0FOTk9UX0FDVElWQVRFOiAnQ0FOTk9UX0FDVElWQVRFJyxcclxuICAgIFRSQU5TSVRJT05fRVJSOiAnVFJBTlNJVElPTl9FUlInLFxyXG4gICAgVFJBTlNJVElPTl9DQU5DRUxMRUQ6ICdDQU5DRUxMRUQnXHJcbn07XHJcbnZhciBjb25zdGFudHMgPSB7XHJcbiAgICBVTktOT1dOX1JPVVRFOiAnQEByb3V0ZXI1L1VOS05PV05fUk9VVEUnLFxyXG4gICAgUk9VVEVSX1NUQVJUOiAnJHN0YXJ0JyxcclxuICAgIFJPVVRFUl9TVE9QOiAnJHN0b3AnLFxyXG4gICAgVFJBTlNJVElPTl9TVEFSVDogJyQkc3RhcnQnLFxyXG4gICAgVFJBTlNJVElPTl9DQU5DRUw6ICckJGNhbmNlbCcsXHJcbiAgICBUUkFOU0lUSU9OX1NVQ0NFU1M6ICckJHN1Y2Nlc3MnLFxyXG4gICAgVFJBTlNJVElPTl9FUlJPUjogJyQkZXJyb3InXHJcbn07XG5cbmZ1bmN0aW9uIHdpdGhSb3V0ZXMocm91dGVzKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJvdXRlcikge1xyXG4gICAgICAgIHJvdXRlci5mb3J3YXJkID0gZnVuY3Rpb24gKGZyb21Sb3V0ZSwgdG9Sb3V0ZSkge1xyXG4gICAgICAgICAgICByb3V0ZXIuY29uZmlnLmZvcndhcmRNYXBbZnJvbVJvdXRlXSA9IHRvUm91dGU7XHJcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcm9vdE5vZGUgPSByb3V0ZXMgaW5zdGFuY2VvZiBSb3V0ZU5vZGVcclxuICAgICAgICAgICAgPyByb3V0ZXNcclxuICAgICAgICAgICAgOiBuZXcgUm91dGVOb2RlKCcnLCAnJywgcm91dGVzLCB7IG9uQWRkOiBvblJvdXRlQWRkZWQgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gb25Sb3V0ZUFkZGVkKHJvdXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChyb3V0ZS5jYW5BY3RpdmF0ZSlcclxuICAgICAgICAgICAgICAgIHJvdXRlci5jYW5BY3RpdmF0ZShyb3V0ZS5uYW1lLCByb3V0ZS5jYW5BY3RpdmF0ZSk7XHJcbiAgICAgICAgICAgIGlmIChyb3V0ZS5mb3J3YXJkVG8pXHJcbiAgICAgICAgICAgICAgICByb3V0ZXIuZm9yd2FyZChyb3V0ZS5uYW1lLCByb3V0ZS5mb3J3YXJkVG8pO1xyXG4gICAgICAgICAgICBpZiAocm91dGUuZGVjb2RlUGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgcm91dGVyLmNvbmZpZy5kZWNvZGVyc1tyb3V0ZS5uYW1lXSA9IHJvdXRlLmRlY29kZVBhcmFtcztcclxuICAgICAgICAgICAgaWYgKHJvdXRlLmVuY29kZVBhcmFtcylcclxuICAgICAgICAgICAgICAgIHJvdXRlci5jb25maWcuZW5jb2RlcnNbcm91dGUubmFtZV0gPSByb3V0ZS5lbmNvZGVQYXJhbXM7XHJcbiAgICAgICAgICAgIGlmIChyb3V0ZS5kZWZhdWx0UGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgcm91dGVyLmNvbmZpZy5kZWZhdWx0UGFyYW1zW3JvdXRlLm5hbWVdID0gcm91dGUuZGVmYXVsdFBhcmFtcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcm91dGVyLnJvb3ROb2RlID0gcm9vdE5vZGU7XHJcbiAgICAgICAgcm91dGVyLmFkZCA9IGZ1bmN0aW9uIChyb3V0ZXMsIGZpbmFsU29ydCkge1xyXG4gICAgICAgICAgICByb290Tm9kZS5hZGQocm91dGVzLCBvblJvdXRlQWRkZWQsICFmaW5hbFNvcnQpO1xyXG4gICAgICAgICAgICBpZiAoZmluYWxTb3J0KSB7XHJcbiAgICAgICAgICAgICAgICByb290Tm9kZS5zb3J0RGVzY2VuZGFudHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcm91dGVyLmFkZE5vZGUgPSBmdW5jdGlvbiAobmFtZSwgcGF0aCwgY2FuQWN0aXZhdGVIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHJvb3ROb2RlLmFkZE5vZGUobmFtZSwgcGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChjYW5BY3RpdmF0ZUhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICByb3V0ZXIuY2FuQWN0aXZhdGUobmFtZSwgY2FuQWN0aXZhdGVIYW5kbGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJvdXRlci5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMsIHN0cmljdEVxdWFsaXR5LCBpZ25vcmVRdWVyeVBhcmFtcykge1xyXG4gICAgICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cclxuICAgICAgICAgICAgaWYgKHN0cmljdEVxdWFsaXR5ID09PSB2b2lkIDApIHsgc3RyaWN0RXF1YWxpdHkgPSBmYWxzZTsgfVxyXG4gICAgICAgICAgICBpZiAoaWdub3JlUXVlcnlQYXJhbXMgPT09IHZvaWQgMCkgeyBpZ25vcmVRdWVyeVBhcmFtcyA9IHRydWU7IH1cclxuICAgICAgICAgICAgdmFyIGFjdGl2ZVN0YXRlID0gcm91dGVyLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgIGlmICghYWN0aXZlU3RhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChzdHJpY3RFcXVhbGl0eSB8fCBhY3RpdmVTdGF0ZS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVyLmFyZVN0YXRlc0VxdWFsKHJvdXRlci5tYWtlU3RhdGUobmFtZSwgcGFyYW1zKSwgYWN0aXZlU3RhdGUsIGlnbm9yZVF1ZXJ5UGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLmFyZVN0YXRlc0Rlc2NlbmRhbnRzKHJvdXRlci5tYWtlU3RhdGUobmFtZSwgcGFyYW1zKSwgYWN0aXZlU3RhdGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcm91dGVyLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChyb3V0ZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChyb3V0ZSA9PT0gY29uc3RhbnRzLlVOS05PV05fUk9VVEUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXMucGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zV2l0aERlZmF1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcm91dGVyLmNvbmZpZy5kZWZhdWx0UGFyYW1zW3JvdXRlXSksIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHJvdXRlci5nZXRPcHRpb25zKCksIHRyYWlsaW5nU2xhc2hNb2RlID0gX2EudHJhaWxpbmdTbGFzaE1vZGUsIHF1ZXJ5UGFyYW1zTW9kZSA9IF9hLnF1ZXJ5UGFyYW1zTW9kZSwgcXVlcnlQYXJhbXMgPSBfYS5xdWVyeVBhcmFtcztcclxuICAgICAgICAgICAgdmFyIGVuY29kZWRQYXJhbXMgPSByb3V0ZXIuY29uZmlnLmVuY29kZXJzW3JvdXRlXVxyXG4gICAgICAgICAgICAgICAgPyByb3V0ZXIuY29uZmlnLmVuY29kZXJzW3JvdXRlXShwYXJhbXNXaXRoRGVmYXVsdClcclxuICAgICAgICAgICAgICAgIDogcGFyYW1zV2l0aERlZmF1bHQ7XHJcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIucm9vdE5vZGUuYnVpbGRQYXRoKHJvdXRlLCBlbmNvZGVkUGFyYW1zLCB7XHJcbiAgICAgICAgICAgICAgICB0cmFpbGluZ1NsYXNoTW9kZTogdHJhaWxpbmdTbGFzaE1vZGUsXHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtc01vZGU6IHF1ZXJ5UGFyYW1zTW9kZSxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc0VuY29kaW5nOiByb3V0ZXIuZ2V0T3B0aW9ucygpLnVybFBhcmFtc0VuY29kaW5nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcm91dGVyLm1hdGNoUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBzb3VyY2UpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSByb3V0ZXIuZ2V0T3B0aW9ucygpO1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSByb3V0ZXIucm9vdE5vZGUubWF0Y2hQYXRoKHBhdGgsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBtYXRjaC5uYW1lLCBwYXJhbXMgPSBtYXRjaC5wYXJhbXMsIG1ldGEgPSBtYXRjaC5tZXRhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY29kZWRQYXJhbXMgPSByb3V0ZXIuY29uZmlnLmRlY29kZXJzW25hbWVfMV1cclxuICAgICAgICAgICAgICAgICAgICA/IHJvdXRlci5jb25maWcuZGVjb2RlcnNbbmFtZV8xXShwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJhbXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSByb3V0ZXIuZm9yd2FyZFN0YXRlKG5hbWVfMSwgZGVjb2RlZFBhcmFtcyksIHJvdXRlTmFtZSA9IF9hLm5hbWUsIHJvdXRlUGFyYW1zID0gX2EucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ1aWx0UGF0aCA9IG9wdGlvbnMucmV3cml0ZVBhdGhPbk1hdGNoID09PSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgID8gcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIDogcm91dGVyLmJ1aWxkUGF0aChyb3V0ZU5hbWUsIHJvdXRlUGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZXIubWFrZVN0YXRlKHJvdXRlTmFtZSwgcm91dGVQYXJhbXMsIGJ1aWx0UGF0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogbWV0YSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByb3V0ZXIuc2V0Um9vdFBhdGggPSBmdW5jdGlvbiAocm9vdFBhdGgpIHtcclxuICAgICAgICAgICAgcm91dGVyLnJvb3ROb2RlLnNldFBhdGgocm9vdFBhdGgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJvdXRlcjtcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gd2l0aERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocm91dGVyKSB7XHJcbiAgICAgICAgdmFyIHJvdXRlckRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcclxuICAgICAgICByb3V0ZXIuc2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChkZXBlbmRlbmN5TmFtZSwgZGVwZW5kZW5jeSkge1xyXG4gICAgICAgICAgICByb3V0ZXJEZXBlbmRlbmNpZXNbZGVwZW5kZW5jeU5hbWVdID0gZGVwZW5kZW5jeTtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJvdXRlci5zZXREZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkZXBzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVyLnNldERlcGVuZGVuY3kobmFtZSwgZGVwc1tuYW1lXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcm91dGVyLmdldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlckRlcGVuZGVuY2llczsgfTtcclxuICAgICAgICByb3V0ZXIuZ2V0SW5qZWN0YWJsZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbcm91dGVyLCByb3V0ZXIuZ2V0RGVwZW5kZW5jaWVzKCldOyB9O1xyXG4gICAgICAgIHJvdXRlci5leGVjdXRlRmFjdG9yeSA9IGZ1bmN0aW9uIChmYWN0b3J5RnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnlGdW5jdGlvbi5hcHBseSh2b2lkIDAsIHJvdXRlci5nZXRJbmplY3RhYmxlcygpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByb3V0ZXI7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIHdpdGhTdGF0ZShyb3V0ZXIpIHtcclxuICAgIHZhciBzdGF0ZUlkID0gMDtcclxuICAgIHZhciByb3V0ZXJTdGF0ZSA9IG51bGw7XHJcbiAgICByb3V0ZXIuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXJTdGF0ZTsgfTtcclxuICAgIHJvdXRlci5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgIHJvdXRlclN0YXRlID0gc3RhdGU7XHJcbiAgICB9O1xyXG4gICAgcm91dGVyLm1ha2VTdGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMsIHBhdGgsIG1ldGEsIGZvcmNlSWQpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICBwYXJhbXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCByb3V0ZXIuY29uZmlnLmRlZmF1bHRQYXJhbXNbbmFtZV0pLCBwYXJhbXMpLFxyXG4gICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgbWV0YTogbWV0YVxyXG4gICAgICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBtZXRhKSwgeyBpZDogZm9yY2VJZCA9PT0gdW5kZWZpbmVkID8gKytzdGF0ZUlkIDogZm9yY2VJZCB9KSA6IHVuZGVmaW5lZFxyXG4gICAgfSk7IH07XHJcbiAgICByb3V0ZXIubWFrZU5vdEZvdW5kU3RhdGUgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiByb3V0ZXIubWFrZVN0YXRlKGNvbnN0YW50cy5VTktOT1dOX1JPVVRFLCB7IHBhdGg6IHBhdGggfSwgcGF0aCwge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcm91dGVyLmFyZVN0YXRlc0VxdWFsID0gZnVuY3Rpb24gKHN0YXRlMSwgc3RhdGUyLCBpZ25vcmVRdWVyeVBhcmFtcykge1xyXG4gICAgICAgIGlmIChpZ25vcmVRdWVyeVBhcmFtcyA9PT0gdm9pZCAwKSB7IGlnbm9yZVF1ZXJ5UGFyYW1zID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChzdGF0ZTEubmFtZSAhPT0gc3RhdGUyLm5hbWUpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgZ2V0VXJsUGFyYW1zID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlci5yb290Tm9kZVxyXG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICAuZ2V0U2VnbWVudHNCeU5hbWUobmFtZSlcclxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHsgcmV0dXJuIHNlZ21lbnQucGFyc2VyWyd1cmxQYXJhbXMnXTsgfSlcclxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHBhcmFtcywgcCkgeyByZXR1cm4gcGFyYW1zLmNvbmNhdChwKTsgfSwgW10pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHN0YXRlMVBhcmFtcyA9IGlnbm9yZVF1ZXJ5UGFyYW1zXHJcbiAgICAgICAgICAgID8gZ2V0VXJsUGFyYW1zKHN0YXRlMS5uYW1lKVxyXG4gICAgICAgICAgICA6IE9iamVjdC5rZXlzKHN0YXRlMS5wYXJhbXMpO1xyXG4gICAgICAgIHZhciBzdGF0ZTJQYXJhbXMgPSBpZ25vcmVRdWVyeVBhcmFtc1xyXG4gICAgICAgICAgICA/IGdldFVybFBhcmFtcyhzdGF0ZTIubmFtZSlcclxuICAgICAgICAgICAgOiBPYmplY3Qua2V5cyhzdGF0ZTIucGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gKHN0YXRlMVBhcmFtcy5sZW5ndGggPT09IHN0YXRlMlBhcmFtcy5sZW5ndGggJiZcclxuICAgICAgICAgICAgc3RhdGUxUGFyYW1zLmV2ZXJ5KGZ1bmN0aW9uIChwKSB7IHJldHVybiBzdGF0ZTEucGFyYW1zW3BdID09PSBzdGF0ZTIucGFyYW1zW3BdOyB9KSk7XHJcbiAgICB9O1xyXG4gICAgcm91dGVyLmFyZVN0YXRlc0Rlc2NlbmRhbnRzID0gZnVuY3Rpb24gKHBhcmVudFN0YXRlLCBjaGlsZFN0YXRlKSB7XHJcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBwYXJlbnRTdGF0ZS5uYW1lICsgJ1xcXFwuKC4qKSQnKTtcclxuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoY2hpbGRTdGF0ZS5uYW1lKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIC8vIElmIGNoaWxkIHN0YXRlIG5hbWUgZXh0ZW5kcyBwYXJlbnQgc3RhdGUgbmFtZSwgYW5kIGFsbCBwYXJlbnQgc3RhdGUgcGFyYW1zXHJcbiAgICAgICAgLy8gYXJlIGluIGNoaWxkIHN0YXRlIHBhcmFtcy5cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyZW50U3RhdGUucGFyYW1zKS5ldmVyeShmdW5jdGlvbiAocCkgeyByZXR1cm4gcGFyZW50U3RhdGUucGFyYW1zW3BdID09PSBjaGlsZFN0YXRlLnBhcmFtc1twXTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcm91dGVyLmZvcndhcmRTdGF0ZSA9IGZ1bmN0aW9uIChyb3V0ZU5hbWUsIHJvdXRlUGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSByb3V0ZXIuY29uZmlnLmZvcndhcmRNYXBbcm91dGVOYW1lXSB8fCByb3V0ZU5hbWU7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCByb3V0ZXIuY29uZmlnLmRlZmF1bHRQYXJhbXNbcm91dGVOYW1lXSksIHJvdXRlci5jb25maWcuZGVmYXVsdFBhcmFtc1tuYW1lXSksIHJvdXRlUGFyYW1zKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcm91dGVyLmJ1aWxkU3RhdGUgPSBmdW5jdGlvbiAocm91dGVOYW1lLCByb3V0ZVBhcmFtcykge1xyXG4gICAgICAgIHZhciBfYSA9IHJvdXRlci5mb3J3YXJkU3RhdGUocm91dGVOYW1lLCByb3V0ZVBhcmFtcyksIG5hbWUgPSBfYS5uYW1lLCBwYXJhbXMgPSBfYS5wYXJhbXM7XHJcbiAgICAgICAgcmV0dXJuIHJvdXRlci5yb290Tm9kZS5idWlsZFN0YXRlKG5hbWUsIHBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHJvdXRlcjtcclxufVxuXG52YXIgZXZlbnRzTWFwID0ge1xyXG4gICAgb25TdGFydDogY29uc3RhbnRzLlJPVVRFUl9TVEFSVCxcclxuICAgIG9uU3RvcDogY29uc3RhbnRzLlJPVVRFUl9TVE9QLFxyXG4gICAgb25UcmFuc2l0aW9uU3VjY2VzczogY29uc3RhbnRzLlRSQU5TSVRJT05fU1VDQ0VTUyxcclxuICAgIG9uVHJhbnNpdGlvblN0YXJ0OiBjb25zdGFudHMuVFJBTlNJVElPTl9TVEFSVCxcclxuICAgIG9uVHJhbnNpdGlvbkVycm9yOiBjb25zdGFudHMuVFJBTlNJVElPTl9FUlJPUixcclxuICAgIG9uVHJhbnNpdGlvbkNhbmNlbDogY29uc3RhbnRzLlRSQU5TSVRJT05fQ0FOQ0VMXHJcbn07XHJcbmZ1bmN0aW9uIHdpdGhQbHVnaW5zKHJvdXRlcikge1xyXG4gICAgdmFyIHJvdXRlclBsdWdpbnMgPSBbXTtcclxuICAgIHJvdXRlci5nZXRQbHVnaW5zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyUGx1Z2luczsgfTtcclxuICAgIHJvdXRlci51c2VQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBsdWdpbnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBwbHVnaW5zW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZW1vdmVQbHVnaW5GbnMgPSBwbHVnaW5zLm1hcChmdW5jdGlvbiAocGx1Z2luKSB7XHJcbiAgICAgICAgICAgIHJvdXRlclBsdWdpbnMucHVzaChwbHVnaW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhcnRQbHVnaW4ocGx1Z2luKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByb3V0ZXJQbHVnaW5zID0gcm91dGVyUGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikgeyByZXR1cm4gcGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xOyB9KTtcclxuICAgICAgICAgICAgcmVtb3ZlUGx1Z2luRm5zLmZvckVhY2goZnVuY3Rpb24gKHJlbW92ZVBsdWdpbikgeyByZXR1cm4gcmVtb3ZlUGx1Z2luKCk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gc3RhcnRQbHVnaW4ocGx1Z2luKSB7XHJcbiAgICAgICAgdmFyIGFwcGxpZWRQbHVnaW4gPSByb3V0ZXIuZXhlY3V0ZUZhY3RvcnkocGx1Z2luKTtcclxuICAgICAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBPYmplY3Qua2V5cyhldmVudHNNYXApXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKGFwcGxpZWRQbHVnaW5bbWV0aG9kTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudHNNYXBbbWV0aG9kTmFtZV0sIGFwcGxpZWRQbHVnaW5bbWV0aG9kTmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZW1vdmVMaXN0ZW5lcikgeyByZXR1cm4gcmVtb3ZlTGlzdGVuZXIoKTsgfSk7XHJcbiAgICAgICAgICAgIGlmIChhcHBsaWVkUGx1Z2luLnRlYXJkb3duKSB7XHJcbiAgICAgICAgICAgICAgICBhcHBsaWVkUGx1Z2luLnRlYXJkb3duKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJvdXRlcjtcclxufVxuXG5mdW5jdGlvbiB3aXRoTWlkZGxld2FyZShyb3V0ZXIpIHtcclxuICAgIHZhciBtaWRkbGV3YXJlRmFjdG9yaWVzID0gW107XHJcbiAgICB2YXIgbWlkZGxld2FyZUZ1bmN0aW9ucyA9IFtdO1xyXG4gICAgcm91dGVyLnVzZU1pZGRsZXdhcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1pZGRsZXdhcmVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbW92ZVBsdWdpbkZucyA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xyXG4gICAgICAgICAgICB2YXIgbWlkZGxld2FyZUZ1bmN0aW9uID0gcm91dGVyLmV4ZWN1dGVGYWN0b3J5KG1pZGRsZXdhcmUpO1xyXG4gICAgICAgICAgICBtaWRkbGV3YXJlRmFjdG9yaWVzLnB1c2gobWlkZGxld2FyZSk7XHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVGdW5jdGlvbnMucHVzaChtaWRkbGV3YXJlRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZUZhY3RvcmllcyA9IG1pZGRsZXdhcmVGYWN0b3JpZXMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtICE9PSBtaWRkbGV3YXJlOyB9KTtcclxuICAgICAgICAgICAgICAgIG1pZGRsZXdhcmVGdW5jdGlvbnMgPSBtaWRkbGV3YXJlRnVuY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gbSAhPT0gbWlkZGxld2FyZUZ1bmN0aW9uOyB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtb3ZlUGx1Z2luRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTsgfTtcclxuICAgIH07XHJcbiAgICByb3V0ZXIuY2xlYXJNaWRkbGV3YXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG1pZGRsZXdhcmVGYWN0b3JpZXMgPSBbXTtcclxuICAgICAgICBtaWRkbGV3YXJlRnVuY3Rpb25zID0gW107XHJcbiAgICAgICAgcmV0dXJuIHJvdXRlcjtcclxuICAgIH07XHJcbiAgICByb3V0ZXIuZ2V0TWlkZGxld2FyZUZhY3RvcmllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pZGRsZXdhcmVGYWN0b3JpZXM7IH07XHJcbiAgICByb3V0ZXIuZ2V0TWlkZGxld2FyZUZ1bmN0aW9ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pZGRsZXdhcmVGdW5jdGlvbnM7IH07XHJcbiAgICByZXR1cm4gcm91dGVyO1xyXG59XG5cbmZ1bmN0aW9uIHdpdGhPYnNlcnZhYmlsaXR5KHJvdXRlcikge1xyXG4gICAgdmFyIGNhbGxiYWNrcyA9IHt9O1xyXG4gICAgcm91dGVyLmludm9rZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKGNhbGxiYWNrc1tldmVudE5hbWVdIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IuYXBwbHkodm9pZCAwLCBhcmdzKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcm91dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYikge1xyXG4gICAgICAgIGNhbGxiYWNrc1tldmVudE5hbWVdID0gY2FsbGJhY2tzW2V2ZW50TmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChfY2IpIHsgcmV0dXJuIF9jYiAhPT0gY2I7IH0pO1xyXG4gICAgfTtcclxuICAgIHJvdXRlci5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2IpIHtcclxuICAgICAgICBjYWxsYmFja3NbZXZlbnROYW1lXSA9IChjYWxsYmFja3NbZXZlbnROYW1lXSB8fCBbXSkuY29uY2F0KGNiKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYik7IH07XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JztcclxuICAgICAgICB2YXIgZmluYWxMaXN0ZW5lciA9IGlzT2JqZWN0ID8gbGlzdGVuZXIubmV4dC5iaW5kKGxpc3RlbmVyKSA6IGxpc3RlbmVyO1xyXG4gICAgICAgIHZhciB1bnN1YnNjcmliZUhhbmRsZXIgPSByb3V0ZXIuYWRkRXZlbnRMaXN0ZW5lcihjb25zdGFudHMuVFJBTlNJVElPTl9TVUNDRVNTLCBmdW5jdGlvbiAodG9TdGF0ZSwgZnJvbVN0YXRlKSB7XHJcbiAgICAgICAgICAgIGZpbmFsTGlzdGVuZXIoe1xyXG4gICAgICAgICAgICAgICAgcm91dGU6IHRvU3RhdGUsXHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c1JvdXRlOiBmcm9tU3RhdGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0XHJcbiAgICAgICAgICAgID8geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVIYW5kbGVyIH1cclxuICAgICAgICAgICAgOiB1bnN1YnNjcmliZUhhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gX2EgPSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmUob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfYVskJG9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9hO1xyXG4gICAgfVxyXG4gICAgcm91dGVyLnN1YnNjcmliZSA9IHN1YnNjcmliZTtcclxuICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgcm91dGVyWyQkb2JzZXJ2YWJsZV0gPSBvYnNlcnZhYmxlO1xyXG4gICAgLy9AdHMtaWdub3JlXHJcbiAgICByb3V0ZXJbJ0BAb2JzZXJ2YWJsZSddID0gb2JzZXJ2YWJsZTtcclxuICAgIHJldHVybiByb3V0ZXI7XHJcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShmdW5jdGlvbnMsIF9hLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGlzQ2FuY2VsbGVkID0gX2EuaXNDYW5jZWxsZWQsIHRvU3RhdGUgPSBfYS50b1N0YXRlLCBmcm9tU3RhdGUgPSBfYS5mcm9tU3RhdGUsIF9iID0gX2EuZXJyb3JLZXksIGVycm9yS2V5ID0gX2IgPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9iO1xyXG4gICAgdmFyIHJlbWFpbmluZ0Z1bmN0aW9ucyA9IEFycmF5LmlzQXJyYXkoZnVuY3Rpb25zKVxyXG4gICAgICAgID8gZnVuY3Rpb25zXHJcbiAgICAgICAgOiBPYmplY3Qua2V5cyhmdW5jdGlvbnMpO1xyXG4gICAgdmFyIGlzU3RhdGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgIG9iai5uYW1lICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgb2JqLnBhcmFtcyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIG9iai5wYXRoICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgdmFyIGhhc1N0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uICh0b1N0YXRlLCBmcm9tU3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gZnJvbVN0YXRlLm5hbWUgIT09IHRvU3RhdGUubmFtZSB8fFxyXG4gICAgICAgICAgICBmcm9tU3RhdGUucGFyYW1zICE9PSB0b1N0YXRlLnBhcmFtcyB8fFxyXG4gICAgICAgICAgICBmcm9tU3RhdGUucGF0aCAhPT0gdG9TdGF0ZS5wYXRoO1xyXG4gICAgfTtcclxuICAgIHZhciBtZXJnZVN0YXRlcyA9IGZ1bmN0aW9uICh0b1N0YXRlLCBmcm9tU3RhdGUpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZnJvbVN0YXRlKSwgdG9TdGF0ZSksIHsgbWV0YTogX19hc3NpZ24oX19hc3NpZ24oe30sIGZyb21TdGF0ZS5tZXRhKSwgdG9TdGF0ZS5tZXRhKSB9KSk7IH07XHJcbiAgICB2YXIgcHJvY2Vzc0ZuID0gZnVuY3Rpb24gKHN0ZXBGbiwgZXJyQmFzZSwgc3RhdGUsIF9kb25lKSB7XHJcbiAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoZXJyLCBuZXdTdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBfZG9uZShlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1N0YXRlICYmIG5ld1N0YXRlICE9PSBzdGF0ZSAmJiBpc1N0YXRlKG5ld1N0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1N0YXRlQ2hhbmdlZChuZXdTdGF0ZSwgc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3JvdXRlcjVdW3RyYW5zaXRpb25dIFdhcm5pbmc6IHN0YXRlIHZhbHVlcyAobmFtZSwgcGFyYW1zLCBwYXRoKSB3ZXJlIGNoYW5nZWQgZHVyaW5nIHRyYW5zaXRpb24gcHJvY2Vzcy4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9kb25lKG51bGwsIG1lcmdlU3RhdGVzKG5ld1N0YXRlLCBzdGF0ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2RvbmUobnVsbCwgc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVzID0gc3RlcEZuLmNhbGwobnVsbCwgc3RhdGUsIGZyb21TdGF0ZSwgZG9uZSk7XHJcbiAgICAgICAgaWYgKGlzQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICAgICAgZG9uZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlcyA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIGRvbmUocmVzID8gbnVsbCA6IGVyckJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1N0YXRlKHJlcykpIHtcclxuICAgICAgICAgICAgZG9uZShudWxsLCByZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uIChyZXNWYWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNWYWwgaW5zdGFuY2VvZiBFcnJvcilcclxuICAgICAgICAgICAgICAgICAgICBkb25lKHsgZXJyb3I6IHJlc1ZhbCB9LCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkb25lKG51bGwsIHJlc1ZhbCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrIHx8IGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXJyQmFzZSksIHsgcHJvbWlzZUVycm9yOiBlcnIgfSksIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSh0eXBlb2YgZXJyID09PSAnb2JqZWN0J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBlcnJCYXNlKSwgZXJyKSA6IGVyckJhc2UsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZWxzZTogd2FpdCBmb3IgZG9uZSB0byBiZSBjYWxsZWRcclxuICAgIH07XHJcbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChlcnIsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmIChpc0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVycikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFyZW1haW5pbmdGdW5jdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNNYXBwZWQgPSB0eXBlb2YgcmVtYWluaW5nRnVuY3Rpb25zWzBdID09PSAnc3RyaW5nJztcclxuICAgICAgICAgICAgICAgIHZhciBlcnJCYXNlID0gZXJyb3JLZXkgJiYgaXNNYXBwZWRcclxuICAgICAgICAgICAgICAgICAgICA/IChfYSA9IHt9LCBfYVtlcnJvcktleV0gPSByZW1haW5pbmdGdW5jdGlvbnNbMF0sIF9hKSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBGbiA9IGlzTWFwcGVkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbnNbcmVtYWluaW5nRnVuY3Rpb25zWzBdXVxyXG4gICAgICAgICAgICAgICAgICAgIDogcmVtYWluaW5nRnVuY3Rpb25zWzBdO1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nRnVuY3Rpb25zID0gcmVtYWluaW5nRnVuY3Rpb25zLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZuKHN0ZXBGbiwgZXJyQmFzZSwgc3RhdGUsIG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG5leHQobnVsbCwgdG9TdGF0ZSk7XHJcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbihyb3V0ZXIsIHRvU3RhdGUsIGZyb21TdGF0ZSwgb3B0cywgY2FsbGJhY2spIHtcclxuICAgIHZhciBjYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcclxuICAgIHZhciBvcHRpb25zID0gcm91dGVyLmdldE9wdGlvbnMoKTtcclxuICAgIHZhciBfYSA9IHJvdXRlci5nZXRMaWZlY3ljbGVGdW5jdGlvbnMoKSwgY2FuRGVhY3RpdmF0ZUZ1bmN0aW9ucyA9IF9hWzBdLCBjYW5BY3RpdmF0ZUZ1bmN0aW9ucyA9IF9hWzFdO1xyXG4gICAgdmFyIG1pZGRsZXdhcmVGdW5jdGlvbnMgPSByb3V0ZXIuZ2V0TWlkZGxld2FyZUZ1bmN0aW9ucygpO1xyXG4gICAgdmFyIGlzQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FuY2VsbGVkOyB9O1xyXG4gICAgdmFyIGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWNhbmNlbGxlZCAmJiAhY29tcGxldGVkKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHsgY29kZTogZXJyb3JDb2Rlcy5UUkFOU0lUSU9OX0NBTkNFTExFRCB9LCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoZXJyLCBzdGF0ZSkge1xyXG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGlzQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVyciAmJiBvcHRpb25zLmF1dG9DbGVhblVwKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3RpdmVTZWdtZW50c18xID0gbmFtZVRvSURzKHRvU3RhdGUubmFtZSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNhbkRlYWN0aXZhdGVGdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVTZWdtZW50c18xLmluZGV4T2YobmFtZSkgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlci5jbGVhckNhbkRlYWN0aXZhdGUobmFtZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFjayhlcnIsIHN0YXRlIHx8IHRvU3RhdGUpO1xyXG4gICAgfTtcclxuICAgIHZhciBtYWtlRXJyb3IgPSBmdW5jdGlvbiAoYmFzZSwgZXJyKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGJhc2UpLCAoZXJyIGluc3RhbmNlb2YgT2JqZWN0ID8gZXJyIDogeyBlcnJvcjogZXJyIH0pKSk7IH07XHJcbiAgICB2YXIgaXNVbmtub3duUm91dGUgPSB0b1N0YXRlLm5hbWUgPT09IGNvbnN0YW50cy5VTktOT1dOX1JPVVRFO1xyXG4gICAgdmFyIGFzeW5jQmFzZSA9IHsgaXNDYW5jZWxsZWQ6IGlzQ2FuY2VsbGVkLCB0b1N0YXRlOiB0b1N0YXRlLCBmcm9tU3RhdGU6IGZyb21TdGF0ZSB9O1xyXG4gICAgdmFyIF9iID0gdHJhbnNpdGlvblBhdGgodG9TdGF0ZSwgZnJvbVN0YXRlKSwgdG9EZWFjdGl2YXRlID0gX2IudG9EZWFjdGl2YXRlLCB0b0FjdGl2YXRlID0gX2IudG9BY3RpdmF0ZTtcclxuICAgIHZhciBjYW5EZWFjdGl2YXRlID0gIWZyb21TdGF0ZSB8fCBvcHRzLmZvcmNlRGVhY3RpdmF0ZVxyXG4gICAgICAgID8gW11cclxuICAgICAgICA6IGZ1bmN0aW9uICh0b1N0YXRlLCBmcm9tU3RhdGUsIGNiKSB7XHJcbiAgICAgICAgICAgIHZhciBjYW5EZWFjdGl2YXRlRnVuY3Rpb25NYXAgPSB0b0RlYWN0aXZhdGVcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGNhbkRlYWN0aXZhdGVGdW5jdGlvbnNbbmFtZV07IH0pXHJcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChmbk1hcCwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm5NYXApLCAoX2EgPSB7fSwgX2FbbmFtZV0gPSBjYW5EZWFjdGl2YXRlRnVuY3Rpb25zW25hbWVdLCBfYSkpKTtcclxuICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICByZXNvbHZlKGNhbkRlYWN0aXZhdGVGdW5jdGlvbk1hcCwgX19hc3NpZ24oX19hc3NpZ24oe30sIGFzeW5jQmFzZSksIHsgZXJyb3JLZXk6ICdzZWdtZW50JyB9KSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVyclxyXG4gICAgICAgICAgICAgICAgICAgID8gbWFrZUVycm9yKHsgY29kZTogZXJyb3JDb2Rlcy5DQU5OT1RfREVBQ1RJVkFURSB9LCBlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIHZhciBjYW5BY3RpdmF0ZSA9IGlzVW5rbm93blJvdXRlXHJcbiAgICAgICAgPyBbXVxyXG4gICAgICAgIDogZnVuY3Rpb24gKHRvU3RhdGUsIGZyb21TdGF0ZSwgY2IpIHtcclxuICAgICAgICAgICAgdmFyIGNhbkFjdGl2YXRlRnVuY3Rpb25NYXAgPSB0b0FjdGl2YXRlXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBjYW5BY3RpdmF0ZUZ1bmN0aW9uc1tuYW1lXTsgfSlcclxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGZuTWFwLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmbk1hcCksIChfYSA9IHt9LCBfYVtuYW1lXSA9IGNhbkFjdGl2YXRlRnVuY3Rpb25zW25hbWVdLCBfYSkpKTtcclxuICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICByZXNvbHZlKGNhbkFjdGl2YXRlRnVuY3Rpb25NYXAsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhc3luY0Jhc2UpLCB7IGVycm9yS2V5OiAnc2VnbWVudCcgfSksIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnJcclxuICAgICAgICAgICAgICAgICAgICA/IG1ha2VFcnJvcih7IGNvZGU6IGVycm9yQ29kZXMuQ0FOTk9UX0FDVElWQVRFIH0sIGVycilcclxuICAgICAgICAgICAgICAgICAgICA6IG51bGwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgdmFyIG1pZGRsZXdhcmUgPSAhbWlkZGxld2FyZUZ1bmN0aW9ucy5sZW5ndGhcclxuICAgICAgICA/IFtdXHJcbiAgICAgICAgOiBmdW5jdGlvbiAodG9TdGF0ZSwgZnJvbVN0YXRlLCBjYikge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShtaWRkbGV3YXJlRnVuY3Rpb25zLCBfX2Fzc2lnbih7fSwgYXN5bmNCYXNlKSwgZnVuY3Rpb24gKGVyciwgc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnJcclxuICAgICAgICAgICAgICAgICAgICA/IG1ha2VFcnJvcih7IGNvZGU6IGVycm9yQ29kZXMuVFJBTlNJVElPTl9FUlIgfSwgZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCwgc3RhdGUgfHwgdG9TdGF0ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB2YXIgcGlwZWxpbmUgPSBbXVxyXG4gICAgICAgIC5jb25jYXQoY2FuRGVhY3RpdmF0ZSlcclxuICAgICAgICAuY29uY2F0KGNhbkFjdGl2YXRlKVxyXG4gICAgICAgIC5jb25jYXQobWlkZGxld2FyZSk7XHJcbiAgICByZXNvbHZlKHBpcGVsaW5lLCBhc3luY0Jhc2UsIGRvbmUpO1xyXG4gICAgcmV0dXJuIGNhbmNlbDtcclxufVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuZnVuY3Rpb24gd2l0aE5hdmlnYXRpb24ocm91dGVyKSB7XHJcbiAgICB2YXIgY2FuY2VsQ3VycmVudFRyYW5zaXRpb247XHJcbiAgICByb3V0ZXIubmF2aWdhdGUgPSBuYXZpZ2F0ZTtcclxuICAgIHJvdXRlci5uYXZpZ2F0ZSA9IG5hdmlnYXRlO1xyXG4gICAgcm91dGVyLm5hdmlnYXRlVG9EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0cyA9IHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyA/IGFyZ3NbMF0gOiB7fTtcclxuICAgICAgICB2YXIgZG9uZSA9IGFyZ3MubGVuZ3RoID09PSAyXHJcbiAgICAgICAgICAgID8gYXJnc1sxXVxyXG4gICAgICAgICAgICA6IHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICA/IGFyZ3NbMF1cclxuICAgICAgICAgICAgICAgIDogbm9vcDtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHJvdXRlci5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdFJvdXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0ZShvcHRpb25zLmRlZmF1bHRSb3V0ZSwgb3B0aW9ucy5kZWZhdWx0UGFyYW1zLCBvcHRzLCBkb25lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIH07XHJcbiAgICByb3V0ZXIuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjYW5jZWxDdXJyZW50VHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBjYW5jZWxDdXJyZW50VHJhbnNpdGlvbignbmF2aWdhdGUnKTtcclxuICAgICAgICAgICAgY2FuY2VsQ3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm91dGVyO1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmFtZSA9IGFyZ3NbMF07XHJcbiAgICAgICAgdmFyIGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIGRvbmUgPSB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGxhc3RBcmcgOiBub29wO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcgPyBhcmdzWzFdIDoge307XHJcbiAgICAgICAgdmFyIG9wdHMgPSB0eXBlb2YgYXJnc1syXSA9PT0gJ29iamVjdCcgPyBhcmdzWzJdIDoge307XHJcbiAgICAgICAgaWYgKCFyb3V0ZXIuaXNTdGFydGVkKCkpIHtcclxuICAgICAgICAgICAgZG9uZSh7IGNvZGU6IGVycm9yQ29kZXMuUk9VVEVSX05PVF9TVEFSVEVEIH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlci5idWlsZFN0YXRlKG5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgaWYgKCFyb3V0ZSkge1xyXG4gICAgICAgICAgICB2YXIgZXJyID0geyBjb2RlOiBlcnJvckNvZGVzLlJPVVRFX05PVF9GT1VORCB9O1xyXG4gICAgICAgICAgICBkb25lKGVycik7XHJcbiAgICAgICAgICAgIHJvdXRlci5pbnZva2VFdmVudExpc3RlbmVycyhjb25zdGFudHMuVFJBTlNJVElPTl9FUlJPUiwgbnVsbCwgcm91dGVyLmdldFN0YXRlKCksIGVycik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRvU3RhdGUgPSByb3V0ZXIubWFrZVN0YXRlKHJvdXRlLm5hbWUsIHJvdXRlLnBhcmFtcywgcm91dGVyLmJ1aWxkUGF0aChyb3V0ZS5uYW1lLCByb3V0ZS5wYXJhbXMpLCB7IHBhcmFtczogcm91dGUubWV0YSwgb3B0aW9uczogb3B0cyB9KTtcclxuICAgICAgICB2YXIgc2FtZVN0YXRlcyA9IHJvdXRlci5nZXRTdGF0ZSgpXHJcbiAgICAgICAgICAgID8gcm91dGVyLmFyZVN0YXRlc0VxdWFsKHJvdXRlci5nZXRTdGF0ZSgpLCB0b1N0YXRlLCBmYWxzZSlcclxuICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICAvLyBEbyBub3QgcHJvY2VlZCBmdXJ0aGVyIGlmIHN0YXRlcyBhcmUgdGhlIHNhbWUgYW5kIG5vIHJlbG9hZFxyXG4gICAgICAgIC8vIChubyBkZWFjdGl2YXRpb24gYW5kIG5vIGNhbGxiYWNrcylcclxuICAgICAgICBpZiAoc2FtZVN0YXRlcyAmJiAhb3B0cy5yZWxvYWQgJiYgIW9wdHMuZm9yY2UpIHtcclxuICAgICAgICAgICAgdmFyIGVyciA9IHsgY29kZTogZXJyb3JDb2Rlcy5TQU1FX1NUQVRFUyB9O1xyXG4gICAgICAgICAgICBkb25lKGVycik7XHJcbiAgICAgICAgICAgIHJvdXRlci5pbnZva2VFdmVudExpc3RlbmVycyhjb25zdGFudHMuVFJBTlNJVElPTl9FUlJPUiwgdG9TdGF0ZSwgcm91dGVyLmdldFN0YXRlKCksIGVycik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZyb21TdGF0ZSA9IHJvdXRlci5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIGlmIChvcHRzLnNraXBUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGRvbmUobnVsbCwgdG9TdGF0ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmFuc2l0aW9uXHJcbiAgICAgICAgcmV0dXJuIHJvdXRlci50cmFuc2l0aW9uVG9TdGF0ZSh0b1N0YXRlLCBmcm9tU3RhdGUsIG9wdHMsIGZ1bmN0aW9uIChlcnIsIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIucmVkaXJlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBlcnIucmVkaXJlY3QsIG5hbWVfMSA9IF9hLm5hbWUsIHBhcmFtc18xID0gX2EucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlKG5hbWVfMSwgcGFyYW1zXzEsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRzKSwgeyBmb3JjZTogdHJ1ZSwgcmVkaXJlY3RlZDogdHJ1ZSB9KSwgZG9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb3V0ZXIuaW52b2tlRXZlbnRMaXN0ZW5lcnMoY29uc3RhbnRzLlRSQU5TSVRJT05fU1VDQ0VTUywgc3RhdGUsIGZyb21TdGF0ZSwgb3B0cyk7XHJcbiAgICAgICAgICAgICAgICBkb25lKG51bGwsIHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcm91dGVyLnRyYW5zaXRpb25Ub1N0YXRlID0gZnVuY3Rpb24gKHRvU3RhdGUsIGZyb21TdGF0ZSwgb3B0aW9ucywgZG9uZSkge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKGRvbmUgPT09IHZvaWQgMCkgeyBkb25lID0gbm9vcDsgfVxyXG4gICAgICAgIHJvdXRlci5jYW5jZWwoKTtcclxuICAgICAgICByb3V0ZXIuaW52b2tlRXZlbnRMaXN0ZW5lcnMoY29uc3RhbnRzLlRSQU5TSVRJT05fU1RBUlQsIHRvU3RhdGUsIGZyb21TdGF0ZSk7XHJcbiAgICAgICAgY2FuY2VsQ3VycmVudFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uKHJvdXRlciwgdG9TdGF0ZSwgZnJvbVN0YXRlLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBzdGF0ZSkge1xyXG4gICAgICAgICAgICBjYW5jZWxDdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUgfHwgdG9TdGF0ZTtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSBlcnJvckNvZGVzLlRSQU5TSVRJT05fQ0FOQ0VMTEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyLmludm9rZUV2ZW50TGlzdGVuZXJzKGNvbnN0YW50cy5UUkFOU0lUSU9OX0NBTkNFTCwgdG9TdGF0ZSwgZnJvbVN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlci5pbnZva2VFdmVudExpc3RlbmVycyhjb25zdGFudHMuVFJBTlNJVElPTl9FUlJPUiwgdG9TdGF0ZSwgZnJvbVN0YXRlLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZG9uZShlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm91dGVyLnNldFN0YXRlKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNhbmNlbEN1cnJlbnRUcmFuc2l0aW9uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiByb3V0ZXI7XHJcbn1cblxudmFyIG5vb3AkMSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuZnVuY3Rpb24gd2l0aFJvdXRlckxpZmVjeWNsZShyb3V0ZXIpIHtcclxuICAgIHZhciBzdGFydGVkID0gZmFsc2U7XHJcbiAgICByb3V0ZXIuaXNTdGFydGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhcnRlZDsgfTtcclxuICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgcm91dGVyLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHJvdXRlci5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgdmFyIGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIGRvbmUgPSB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGxhc3RBcmcgOiBub29wJDE7XHJcbiAgICAgICAgdmFyIHN0YXJ0UGF0aE9yU3RhdGUgPSB0eXBlb2YgYXJnc1swXSAhPT0gJ2Z1bmN0aW9uJyA/IGFyZ3NbMF0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgZG9uZSh7IGNvZGU6IGVycm9yQ29kZXMuUk9VVEVSX0FMUkVBRFlfU1RBUlRFRCB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0UGF0aCwgc3RhcnRTdGF0ZTtcclxuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICByb3V0ZXIuaW52b2tlRXZlbnRMaXN0ZW5lcnMoY29uc3RhbnRzLlJPVVRFUl9TVEFSVCk7XHJcbiAgICAgICAgLy8gY2FsbGJhY2tcclxuICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoZXJyLCBzdGF0ZSwgaW52b2tlRXJyQ2IpIHtcclxuICAgICAgICAgICAgaWYgKGludm9rZUVyckNiID09PSB2b2lkIDApIHsgaW52b2tlRXJyQ2IgPSB0cnVlOyB9XHJcbiAgICAgICAgICAgIGlmICghZXJyKVxyXG4gICAgICAgICAgICAgICAgcm91dGVyLmludm9rZUV2ZW50TGlzdGVuZXJzKGNvbnN0YW50cy5UUkFOU0lUSU9OX1NVQ0NFU1MsIHN0YXRlLCBudWxsLCB7IHJlcGxhY2U6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIGlmIChlcnIgJiYgaW52b2tlRXJyQ2IpXHJcbiAgICAgICAgICAgICAgICByb3V0ZXIuaW52b2tlRXZlbnRMaXN0ZW5lcnMoY29uc3RhbnRzLlRSQU5TSVRJT05fRVJST1IsIHN0YXRlLCBudWxsLCBlcnIpO1xyXG4gICAgICAgICAgICBkb25lKGVyciwgc3RhdGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHN0YXJ0UGF0aE9yU3RhdGUgPT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5kZWZhdWx0Um91dGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNiKHsgY29kZTogZXJyb3JDb2Rlcy5OT19TVEFSVF9QQVRIX09SX1NUQVRFIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0UGF0aE9yU3RhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UGF0aCA9IHN0YXJ0UGF0aE9yU3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGFydFBhdGhPclN0YXRlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBzdGFydFN0YXRlID0gc3RhcnRQYXRoT3JTdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdGFydFN0YXRlKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIHN1cHBsaWVkIHN0YXJ0IHN0YXRlLCBnZXQgc3RhcnQgc3RhdGVcclxuICAgICAgICAgICAgc3RhcnRTdGF0ZSA9XHJcbiAgICAgICAgICAgICAgICBzdGFydFBhdGggPT09IHVuZGVmaW5lZCA/IG51bGwgOiByb3V0ZXIubWF0Y2hQYXRoKHN0YXJ0UGF0aCk7XHJcbiAgICAgICAgICAgIC8vIE5hdmlnYXRlIHRvIGRlZmF1bHQgZnVuY3Rpb25cclxuICAgICAgICAgICAgdmFyIG5hdmlnYXRlVG9EZWZhdWx0XzEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVyLm5hdmlnYXRlVG9EZWZhdWx0KHsgcmVwbGFjZTogdHJ1ZSB9LCBkb25lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHJlZGlyZWN0XzEgPSBmdW5jdGlvbiAocm91dGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZXIubmF2aWdhdGUocm91dGUubmFtZSwgcm91dGUucGFyYW1zLCB7IHJlcGxhY2U6IHRydWUsIHJlbG9hZDogdHJ1ZSwgcmVkaXJlY3RlZDogdHJ1ZSB9LCBkb25lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25Ub1N0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICByb3V0ZXIudHJhbnNpdGlvblRvU3RhdGUoc3RhdGUsIHJvdXRlci5nZXRTdGF0ZSgpLCB7fSwgZnVuY3Rpb24gKGVyciwgc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyci5yZWRpcmVjdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RfMShlcnIucmVkaXJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZGVmYXVsdFJvdXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRGVmYXVsdF8xKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYihlcnIsIG51bGwsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBJZiBtYXRjaGVkIHN0YXJ0IHBhdGhcclxuICAgICAgICAgICAgaWYgKHN0YXJ0U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25Ub1N0YXRlKHN0YXJ0U3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZGVmYXVsdFJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkZWZhdWx0LCBuYXZpZ2F0ZSB0byBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRGVmYXVsdF8xKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5hbGxvd05vdEZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uVG9TdGF0ZShyb3V0ZXIubWFrZU5vdEZvdW5kU3RhdGUoc3RhcnRQYXRoLCB7IHJlcGxhY2U6IHRydWUgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gc3RhcnQgbWF0Y2gsIG5vIGRlZmF1bHQgPT4gZG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgY2IoeyBjb2RlOiBlcnJvckNvZGVzLlJPVVRFX05PVF9GT1VORCwgcGF0aDogc3RhcnRQYXRoIH0sIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXNlIHJvdXRlciB3aXRoIHByb3ZpZGVkIHN0YXJ0IHN0YXRlXHJcbiAgICAgICAgICAgIHJvdXRlci5zZXRTdGF0ZShzdGFydFN0YXRlKTtcclxuICAgICAgICAgICAgY2IobnVsbCwgc3RhcnRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb3V0ZXI7XHJcbiAgICB9O1xyXG4gICAgcm91dGVyLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcm91dGVyLnNldFN0YXRlKG51bGwpO1xyXG4gICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJvdXRlci5pbnZva2VFdmVudExpc3RlbmVycyhjb25zdGFudHMuUk9VVEVSX1NUT1ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm91dGVyO1xyXG4gICAgfTtcclxuICAgIHJldHVybiByb3V0ZXI7XHJcbn1cblxudmFyIHRvRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHZhbCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbDsgfTsgfSk7IH07XHJcbmZ1bmN0aW9uIHdpdGhSb3V0ZUxpZmVjeWNsZShyb3V0ZXIpIHtcclxuICAgIHZhciBjYW5EZWFjdGl2YXRlRmFjdG9yaWVzID0ge307XHJcbiAgICB2YXIgY2FuQWN0aXZhdGVGYWN0b3JpZXMgPSB7fTtcclxuICAgIHZhciBjYW5EZWFjdGl2YXRlRnVuY3Rpb25zID0ge307XHJcbiAgICB2YXIgY2FuQWN0aXZhdGVGdW5jdGlvbnMgPSB7fTtcclxuICAgIHJvdXRlci5nZXRMaWZlY3ljbGVGYWN0b3JpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtjYW5EZWFjdGl2YXRlRmFjdG9yaWVzLCBjYW5BY3RpdmF0ZUZhY3Rvcmllc107XHJcbiAgICB9O1xyXG4gICAgcm91dGVyLmdldExpZmVjeWNsZUZ1bmN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW2NhbkRlYWN0aXZhdGVGdW5jdGlvbnMsIGNhbkFjdGl2YXRlRnVuY3Rpb25zXTtcclxuICAgIH07XHJcbiAgICByb3V0ZXIuY2FuRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBjYW5EZWFjdGl2YXRlSGFuZGxlcikge1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdG9GdW5jdGlvbihjYW5EZWFjdGl2YXRlSGFuZGxlcik7XHJcbiAgICAgICAgY2FuRGVhY3RpdmF0ZUZhY3Rvcmllc1tuYW1lXSA9IGZhY3Rvcnk7XHJcbiAgICAgICAgY2FuRGVhY3RpdmF0ZUZ1bmN0aW9uc1tuYW1lXSA9IHJvdXRlci5leGVjdXRlRmFjdG9yeShmYWN0b3J5KTtcclxuICAgICAgICByZXR1cm4gcm91dGVyO1xyXG4gICAgfTtcclxuICAgIHJvdXRlci5jbGVhckNhbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGNhbkRlYWN0aXZhdGVGYWN0b3JpZXNbbmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY2FuRGVhY3RpdmF0ZUZ1bmN0aW9uc1tuYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gcm91dGVyO1xyXG4gICAgfTtcclxuICAgIHJvdXRlci5jYW5BY3RpdmF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBjYW5BY3RpdmF0ZUhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgZmFjdG9yeSA9IHRvRnVuY3Rpb24oY2FuQWN0aXZhdGVIYW5kbGVyKTtcclxuICAgICAgICBjYW5BY3RpdmF0ZUZhY3Rvcmllc1tuYW1lXSA9IGZhY3Rvcnk7XHJcbiAgICAgICAgY2FuQWN0aXZhdGVGdW5jdGlvbnNbbmFtZV0gPSByb3V0ZXIuZXhlY3V0ZUZhY3RvcnkoZmFjdG9yeSk7XHJcbiAgICAgICAgcmV0dXJuIHJvdXRlcjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gcm91dGVyO1xyXG59XG5cbnZhciBwaXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGZucyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBmbnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZucy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGZuKSB7IHJldHVybiBmbihwcmV2KTsgfSwgYXJnKTtcclxuICAgIH07XHJcbn07XHJcbnZhciBjcmVhdGVSb3V0ZXIgPSBmdW5jdGlvbiAocm91dGVzLCBvcHRpb25zLCBkZXBlbmRlbmNpZXMpIHtcclxuICAgIGlmIChyb3V0ZXMgPT09IHZvaWQgMCkgeyByb3V0ZXMgPSBbXTsgfVxyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSB7fTsgfVxyXG4gICAgdmFyIGNvbmZpZyA9IHtcclxuICAgICAgICBkZWNvZGVyczoge30sXHJcbiAgICAgICAgZW5jb2RlcnM6IHt9LFxyXG4gICAgICAgIGRlZmF1bHRQYXJhbXM6IHt9LFxyXG4gICAgICAgIGZvcndhcmRNYXA6IHt9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHBpcGUod2l0aE9wdGlvbnMob3B0aW9ucyksIHdpdGhEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSwgd2l0aE9ic2VydmFiaWxpdHksIHdpdGhTdGF0ZSwgd2l0aFJvdXRlckxpZmVjeWNsZSwgd2l0aFJvdXRlTGlmZWN5Y2xlLCB3aXRoTmF2aWdhdGlvbiwgd2l0aFBsdWdpbnMsIHdpdGhNaWRkbGV3YXJlLCB3aXRoUm91dGVzKHJvdXRlcykpKHsgY29uZmlnOiBjb25maWcgfSk7XHJcbn07XG5cbmZ1bmN0aW9uIGNsb25lUm91dGVyKHJvdXRlciwgZGVwZW5kZW5jaWVzKSB7XHJcbiAgICB2YXIgY2xvbmVkUm91dGVyID0gY3JlYXRlUm91dGVyKHJvdXRlci5yb290Tm9kZSwgcm91dGVyLmdldE9wdGlvbnMoKSwgZGVwZW5kZW5jaWVzKTtcclxuICAgIGNsb25lZFJvdXRlci51c2VNaWRkbGV3YXJlLmFwcGx5KGNsb25lZFJvdXRlciwgcm91dGVyLmdldE1pZGRsZXdhcmVGYWN0b3JpZXMoKSk7XHJcbiAgICBjbG9uZWRSb3V0ZXIudXNlUGx1Z2luLmFwcGx5KGNsb25lZFJvdXRlciwgcm91dGVyLmdldFBsdWdpbnMoKSk7XHJcbiAgICBjbG9uZWRSb3V0ZXIuY29uZmlnID0gcm91dGVyLmNvbmZpZztcclxuICAgIHZhciBfYSA9IHJvdXRlci5nZXRMaWZlY3ljbGVGYWN0b3JpZXMoKSwgY2FuRGVhY3RpdmF0ZUZhY3RvcmllcyA9IF9hWzBdLCBjYW5BY3RpdmF0ZUZhY3RvcmllcyA9IF9hWzFdO1xyXG4gICAgT2JqZWN0LmtleXMoY2FuRGVhY3RpdmF0ZUZhY3RvcmllcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBjbG9uZWRSb3V0ZXIuY2FuRGVhY3RpdmF0ZShuYW1lLCBjYW5EZWFjdGl2YXRlRmFjdG9yaWVzW25hbWVdKTtcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmtleXMoY2FuQWN0aXZhdGVGYWN0b3JpZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gY2xvbmVkUm91dGVyLmNhbkFjdGl2YXRlKG5hbWUsIGNhbkFjdGl2YXRlRmFjdG9yaWVzW25hbWVdKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNsb25lZFJvdXRlcjtcclxufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSb3V0ZXI7XG5leHBvcnQgeyBjbG9uZVJvdXRlciwgY29uc3RhbnRzLCBjcmVhdGVSb3V0ZXIsIGVycm9yQ29kZXMgfTtcbiIsInZhciBtYWtlT3B0aW9ucyA9IGZ1bmN0aW9uIG1ha2VPcHRpb25zKG9wdHMpIHtcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXJyYXlGb3JtYXQ6IG9wdHMuYXJyYXlGb3JtYXQgfHwgJ25vbmUnLFxuICAgIGJvb2xlYW5Gb3JtYXQ6IG9wdHMuYm9vbGVhbkZvcm1hdCB8fCAnbm9uZScsXG4gICAgbnVsbEZvcm1hdDogb3B0cy5udWxsRm9ybWF0IHx8ICdkZWZhdWx0J1xuICB9O1xufTtcblxudmFyIGVuY29kZVZhbHVlID0gZnVuY3Rpb24gZW5jb2RlVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG59O1xuXG52YXIgZGVjb2RlVmFsdWUgPSBmdW5jdGlvbiBkZWNvZGVWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbn07XG5cbnZhciBlbmNvZGVCb29sZWFuID0gZnVuY3Rpb24gZW5jb2RlQm9vbGVhbihuYW1lLCB2YWx1ZSwgb3B0cykge1xuICBpZiAob3B0cy5ib29sZWFuRm9ybWF0ID09PSAnZW1wdHktdHJ1ZScgJiYgdmFsdWUpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIHZhciBlbmNvZGVkVmFsdWU7XG5cbiAgaWYgKG9wdHMuYm9vbGVhbkZvcm1hdCA9PT0gJ3VuaWNvZGUnKSB7XG4gICAgZW5jb2RlZFZhbHVlID0gdmFsdWUgPyAn4pyTJyA6ICfinJcnO1xuICB9IGVsc2Uge1xuICAgIGVuY29kZWRWYWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXR1cm4gbmFtZSArIFwiPVwiICsgZW5jb2RlZFZhbHVlO1xufTtcblxudmFyIGVuY29kZU51bGwgPSBmdW5jdGlvbiBlbmNvZGVOdWxsKG5hbWUsIG9wdHMpIHtcbiAgaWYgKG9wdHMubnVsbEZvcm1hdCA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAob3B0cy5udWxsRm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuYW1lICsgXCI9bnVsbFwiO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG52YXIgZ2V0TmFtZUVuY29kZXIgPSBmdW5jdGlvbiBnZXROYW1lRW5jb2RlcihvcHRzKSB7XG4gIGlmIChvcHRzLmFycmF5Rm9ybWF0ID09PSAnaW5kZXgnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICAgICAgcmV0dXJuIG5hbWUgKyBcIltcIiArIGluZGV4ICsgXCJdXCI7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChvcHRzLmFycmF5Rm9ybWF0ID09PSAnYnJhY2tldHMnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSArIFwiW11cIjtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG59O1xuXG52YXIgZW5jb2RlQXJyYXkgPSBmdW5jdGlvbiBlbmNvZGVBcnJheShuYW1lLCBhcnIsIG9wdHMpIHtcbiAgdmFyIGVuY29kZU5hbWUgPSBnZXROYW1lRW5jb2RlcihvcHRzKTtcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICByZXR1cm4gZW5jb2RlTmFtZShuYW1lLCBpbmRleCkgKyBcIj1cIiArIGVuY29kZVZhbHVlKHZhbCk7XG4gIH0pLmpvaW4oJyYnKTtcbn07XG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG5hbWUsIHZhbHVlLCBvcHRzKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBlbmNvZGVOdWxsKG5hbWUsIG9wdHMpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGVuY29kZUJvb2xlYW4obmFtZSwgdmFsdWUsIG9wdHMpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5KG5hbWUsIHZhbHVlLCBvcHRzKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lICsgXCI9XCIgKyBlbmNvZGVWYWx1ZSh2YWx1ZSk7XG59O1xudmFyIGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZSh2YWx1ZSwgb3B0cykge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvcHRzLmJvb2xlYW5Gb3JtYXQgPT09ICdlbXB0eS10cnVlJyA/IHRydWUgOiBudWxsO1xuICB9XG5cbiAgaWYgKG9wdHMuYm9vbGVhbkZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuYm9vbGVhbkZvcm1hdCA9PT0gJ3VuaWNvZGUnKSB7XG4gICAgaWYgKGRlY29kZVZhbHVlKHZhbHVlKSA9PT0gJ+KckycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkZWNvZGVWYWx1ZSh2YWx1ZSkgPT09ICfinJcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMubnVsbEZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsdWUgPT09ICdudWxsJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZVZhbHVlKHZhbHVlKTtcbn07XG5cbnZhciBnZXRTZWFyY2ggPSBmdW5jdGlvbiBnZXRTZWFyY2gocGF0aCkge1xuICB2YXIgcG9zID0gcGF0aC5pbmRleE9mKCc/Jyk7XG5cbiAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIHJldHVybiBwYXRoLnNsaWNlKHBvcyArIDEpO1xufTtcbnZhciBpc1NlcmlhbGlzYWJsZSA9IGZ1bmN0aW9uIGlzU2VyaWFsaXNhYmxlKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQ7XG59O1xudmFyIHBhcnNlTmFtZSA9IGZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XG4gIHZhciBicmFja2V0UG9zaXRpb24gPSBuYW1lLmluZGV4T2YoJ1snKTtcbiAgdmFyIGhhc0JyYWNrZXRzID0gYnJhY2tldFBvc2l0aW9uICE9PSAtMTtcbiAgcmV0dXJuIHtcbiAgICBoYXNCcmFja2V0czogaGFzQnJhY2tldHMsXG4gICAgbmFtZTogaGFzQnJhY2tldHMgPyBuYW1lLnNsaWNlKDAsIGJyYWNrZXRQb3NpdGlvbikgOiBuYW1lXG4gIH07XG59O1xuXG4vKipcclxuICogUGFyc2UgYSBxdWVyeXN0cmluZyBhbmQgcmV0dXJuIGFuIG9iamVjdCBvZiBwYXJhbWV0ZXJzXHJcbiAqL1xuXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShwYXRoLCBvcHRzKSB7XG4gIHZhciBvcHRpb25zID0gbWFrZU9wdGlvbnMob3B0cyk7XG4gIHJldHVybiBnZXRTZWFyY2gocGF0aCkuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKHBhcmFtcywgcGFyYW0pIHtcbiAgICB2YXIgX2EgPSBwYXJhbS5zcGxpdCgnPScpLFxuICAgICAgICByYXdOYW1lID0gX2FbMF0sXG4gICAgICAgIHZhbHVlID0gX2FbMV07XG5cbiAgICB2YXIgX2IgPSBwYXJzZU5hbWUocmF3TmFtZSksXG4gICAgICAgIGhhc0JyYWNrZXRzID0gX2IuaGFzQnJhY2tldHMsXG4gICAgICAgIG5hbWUgPSBfYi5uYW1lO1xuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHBhcmFtc1tuYW1lXTtcbiAgICB2YXIgZGVjb2RlZFZhbHVlID0gZGVjb2RlKHZhbHVlLCBvcHRpb25zKTtcblxuICAgIGlmIChjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW1zW25hbWVdID0gaGFzQnJhY2tldHMgPyBbZGVjb2RlZFZhbHVlXSA6IGRlY29kZWRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zW25hbWVdID0gKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IFtjdXJyZW50VmFsdWVdKS5jb25jYXQoZGVjb2RlZFZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9LCB7fSk7XG59O1xuLyoqXHJcbiAqIEJ1aWxkIGEgcXVlcnlzdHJpbmcgZnJvbSBhbiBvYmplY3Qgb2YgcGFyYW1ldGVyc1xyXG4gKi9cblxudmFyIGJ1aWxkID0gZnVuY3Rpb24gYnVpbGQocGFyYW1zLCBvcHRzKSB7XG4gIHZhciBvcHRpb25zID0gbWFrZU9wdGlvbnMob3B0cyk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLmZpbHRlcihmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgcmV0dXJuIGlzU2VyaWFsaXNhYmxlKHBhcmFtc1twYXJhbU5hbWVdKTtcbiAgfSkubWFwKGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICByZXR1cm4gZW5jb2RlKHBhcmFtTmFtZSwgcGFyYW1zW3BhcmFtTmFtZV0sIG9wdGlvbnMpO1xuICB9KS5maWx0ZXIoQm9vbGVhbikuam9pbignJicpO1xufTtcbi8qKlxyXG4gKiBSZW1vdmUgYSBsaXN0IG9mIHBhcmFtZXRlcnMgZnJvbSBhIHF1ZXJ5c3RyaW5nXHJcbiAqL1xuXG52YXIgb21pdCA9IGZ1bmN0aW9uIG9taXQocGF0aCwgcGFyYW1zVG9PbWl0LCBvcHRzKSB7XG4gIHZhciBvcHRpb25zID0gbWFrZU9wdGlvbnMob3B0cyk7XG4gIHZhciBzZWFyY2hQYXJ0ID0gZ2V0U2VhcmNoKHBhdGgpO1xuXG4gIGlmIChzZWFyY2hQYXJ0ID09PSAnJykge1xuICAgIHJldHVybiB7XG4gICAgICBxdWVyeXN0cmluZzogJycsXG4gICAgICByZW1vdmVkUGFyYW1zOiB7fVxuICAgIH07XG4gIH1cblxuICB2YXIgX2EgPSBwYXRoLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChfYSwgY2h1bmspIHtcbiAgICB2YXIgbGVmdCA9IF9hWzBdLFxuICAgICAgICByaWdodCA9IF9hWzFdO1xuICAgIHZhciByYXdOYW1lID0gY2h1bmsuc3BsaXQoJz0nKVswXTtcbiAgICB2YXIgbmFtZSA9IHBhcnNlTmFtZShyYXdOYW1lKS5uYW1lO1xuICAgIHJldHVybiBwYXJhbXNUb09taXQuaW5kZXhPZihuYW1lKSA9PT0gLTEgPyBbbGVmdC5jb25jYXQoY2h1bmspLCByaWdodF0gOiBbbGVmdCwgcmlnaHQuY29uY2F0KGNodW5rKV07XG4gIH0sIFtbXSwgW11dKSxcbiAgICAgIGtlcHQgPSBfYVswXSxcbiAgICAgIHJlbW92ZWQgPSBfYVsxXTtcblxuICByZXR1cm4ge1xuICAgIHF1ZXJ5c3RyaW5nOiBrZXB0LmpvaW4oJyYnKSxcbiAgICByZW1vdmVkUGFyYW1zOiBwYXJzZShyZW1vdmVkLmpvaW4oJyYnKSwgb3B0aW9ucylcbiAgfTtcbn07XG4vKipcclxuICogUmVtb3ZlIGEgbGlzdCBvZiBwYXJhbWV0ZXJzIGZyb20gYSBxdWVyeXN0cmluZ1xyXG4gKi9cblxudmFyIGtlZXAgPSBmdW5jdGlvbiBrZWVwKHBhdGgsIHBhcmFtc1RvS2VlcCwgb3B0cykge1xuICB2YXIgb3B0aW9ucyA9IG1ha2VPcHRpb25zKG9wdHMpO1xuICB2YXIgc2VhcmNoUGFydCA9IGdldFNlYXJjaChwYXRoKTtcblxuICBpZiAoc2VhcmNoUGFydCA9PT0gJycpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VwdFBhcmFtczoge30sXG4gICAgICBxdWVyeXN0cmluZzogJydcbiAgICB9O1xuICB9XG5cbiAgdmFyIGtlcHQgPSBwYXRoLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNodW5rKSB7XG4gICAgdmFyIHJhd05hbWUgPSBjaHVuay5zcGxpdCgnPScpWzBdO1xuICAgIHZhciBuYW1lID0gcGFyc2VOYW1lKHJhd05hbWUpLm5hbWU7XG5cbiAgICBpZiAocGFyYW1zVG9LZWVwLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICBhY2MucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIGtlcHRQYXJhbXM6IHBhcnNlKGtlcHQuam9pbignJicpLCBvcHRpb25zKSxcbiAgICBxdWVyeXN0cmluZzoga2VwdC5qb2luKCcmJylcbiAgfTtcbn07XG5cbmV4cG9ydCB7IGJ1aWxkLCBrZWVwLCBvbWl0LCBwYXJzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLXBhcmFtcy5lc20uanMubWFwXG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgcG9ueWZpbGwgZnJvbSAnLi9wb255ZmlsbC5qcyc7XG5cbnZhciByb290O1xuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSBwb255ZmlsbChyb290KTtcbmV4cG9ydCBkZWZhdWx0IHJlc3VsdDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0U3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9